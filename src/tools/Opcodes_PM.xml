<?xml version="1.0"?>
<?xml-stylesheet href="x86optable.xsl" type="text/xsl"?>
<opcodesnippets>
  <jcc>        {
            int tmpEip = cpu.eip + jmp + blockLength;
            cpu.cs.checkAddress(tmpEip);
            cpu.eip = tmpEip;
            return Branch.T1;
        }
        else
        {
            cpu.eip += blockLength;
            return Branch.T2;
        }</jcc>

  <opcode mnemonic="eip_update">
    <return>Branch.T1</return>
    <snippet>        cpu.eip += blockLength;</snippet>
    <args size="0"></args>
  </opcode> 

  <opcode mnemonic="aad">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.aad(cpu, $mask$op1.get);</snippet>
    <args size="8">Ib</args>
  </opcode>

  <opcode mnemonic="aam">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.aam(cpu, $mask$op1.get);</snippet>
    <args size="8">Ib</args>
  </opcode>

  <opcode mnemonic="adc">
    <return>Branch.None</return>
    <snippet>        boolean incf = Processor.getCarryFlag(cpu.flagStatus, cpu.cf, cpu.flagOp1, cpu.flagOp2, cpu.flagResult, cpu.flagIns);
        cpu.flagOp1 = $op1.get;
        cpu.flagOp2 = $op2.get;
        cpu.flagResult = $cast(cpu.flagOp1 + cpu.flagOp2 + (incf ? 1 : 0));
        $op1.set$castcpu.flagResult);
        cpu.flagIns = UCodes.ADC$size;
        cpu.flagStatus = OSZAPC;</snippet>
    <args size="8">AL;Ib</args>
    <args size="8">Eb;Gb</args>
    <args size="8">Eb;Ib</args>
    <args size="8">Gb;Eb</args>
    <args size="16">Ew;Ib</args>
    <args size="32">Ed;Ib</args>
    <args size="32">Ed;Id</args>
    <args size="16">Ew;Iw</args>
    <args size="16">Gw;Ew</args>
    <args size="32">Gd;Ed</args>
    <args size="16">Ew;Gw</args>
    <args size="32">Ed;Gd</args>
    <args size="16">rAX;Iw</args>
    <args size="32">rAX;Id</args>
  </opcode>

  <opcode mnemonic="add">
    <return>Branch.None</return>
    <snippet>        cpu.flagOp1 = $op1.get;
        cpu.flagOp2 = $op2.get;
        cpu.flagResult = $cast(cpu.flagOp1 + cpu.flagOp2);
        $op1.set$castcpu.flagResult);
        cpu.flagIns = UCodes.ADD$size;
        cpu.flagStatus = OSZAPC;</snippet>
    <args size="8">AL;Ib</args>
    <args size="8">Eb;Ib</args>
    <args size="8">Eb;Gb</args>
    <args size="8">Gb;Eb</args>
    <args size="16">Ew;Ib</args>
    <args size="32">Ed;Ib</args>
    <args size="16">Ew;Iw</args>
    <args size="32">Ed;Id</args>
    <args size="16">Gw;Ew</args>
    <args size="32">Gd;Ed</args>
    <args size="16">Ew;Gw</args>
    <args size="32">Ed;Gd</args>
  </opcode>

  <opcode mnemonic="add_o16">
    <return>Branch.None</return>
    <snippet>        cpu.flagOp1 = $op1.get;
        cpu.flagOp2 = $op2.get;
        cpu.flagResult = $cast(cpu.flagOp1 + cpu.flagOp2);
        $op1.set$castcpu.flagResult);
        cpu.flagIns = UCodes.ADD$size;
        cpu.flagStatus = OSZAPC;</snippet>
    <args size="16">rAX;Iw</args>
  </opcode>

  <opcode mnemonic="add_o32">
    <return>Branch.None</return>
    <snippet>        cpu.flagOp1 = $op1.get;
        cpu.flagOp2 = $op2.get;
        cpu.flagResult = $cast(cpu.flagOp1 + cpu.flagOp2);
        $op1.set$castcpu.flagResult);
        cpu.flagIns = UCodes.ADD$size;
        cpu.flagStatus = OSZAPC;</snippet>
    <args size="32">rAX;Id</args>
  </opcode>

  <opcode mnemonic="and">
    <return>Branch.None</return>
    <snippet>        cpu.of = cpu.af = cpu.cf = false;
        cpu.flagResult = $cast($op1.get &amp; $op2.get);
        $op1.set$castcpu.flagResult);
        cpu.flagStatus = SZP;</snippet>
    <args size="8">AL;Ib</args>
    <args size="8">Eb;Gb</args>
    <args size="8">Gb;Eb</args>
    <args size="8">Eb;Ib</args>
    <args size="16">Ew;Gw</args>
    <args size="32">Ed;Gd</args>
    <args size="16">Ew;Ib</args>
    <args size="32">Ed;Ib</args>
    <args size="32">Ed;Id</args>
    <args size="16">Ew;Iw</args>
    <args size="16">Gw;Ew</args>
    <args size="32">Gd;Ed</args>
  </opcode>

  <opcode mnemonic="and_o16">
    <return>Branch.None</return>
    <snippet>        cpu.of = cpu.af = cpu.cf = false;
        cpu.flagResult = $cast($op1.get &amp; $op2.get);
        $op1.set$castcpu.flagResult);
        cpu.flagStatus = SZP;</snippet>
    <args size="16">rAX;Iw</args>
  </opcode>

  <opcode mnemonic="and_o32">
    <return>Branch.None</return>
    <snippet>        cpu.of = cpu.af = cpu.cf = false;
        cpu.flagResult = $cast($op1.get &amp; $op2.get);
        $op1.set$castcpu.flagResult);
        cpu.flagStatus = SZP;</snippet>
    <args size="32">rAX;Id</args>
  </opcode>

  <opcode mnemonic="bswap_o32">
    <return>Branch.None</return>
    <snippet>        $op1.setInteger.reverseBytes($op1.get));</snippet>
    <args size="32">rAXr8</args>
    <args size="32">rCXr9</args>
    <args size="32">rDXr10</args>
    <args size="32">rBXr11</args>
    <args size="32">rSPr12</args>
    <args size="32">rBPr13</args>
    <args size="32">rSIr14</args>
    <args size="32">rDIr15</args>
  </opcode>

  <opcode mnemonic="bsf">
    <return>Branch.None</return>
    <snippet>        if ($op2.get == 0) {
	    cpu.zf(true);
	} else {
	    cpu.zf(false);
	    $op1.setStaticOpcodes.numberOfTrailingZeros($op2.get));
	}</snippet>
    <args size="16">Gw;Ew</args>
    <args size="32">Gd;Ed</args>
  </opcode>

  <opcode mnemonic="bsr">
    <return>Branch.None</return>
    <snippet>        if ($op2.get == 0) {
	    cpu.zf(true);
	} else {
	    cpu.zf(false);
	    $op1.set31-StaticOpcodes.numberOfLeadingZeros($op2.get));
	}</snippet>
    <args size="32">Gd;Ed</args>
  </opcode>
  <opcode mnemonic="bsr">
    <return>Branch.None</return>
    <snippet>        if ($op2.get == 0) {
	    cpu.zf(true);
	} else {
	    cpu.zf(false);
	    $op1.set31-StaticOpcodes.numberOfLeadingZeros($mask$op2.get));
	}</snippet>
    <args size="16">Gw;Ew</args>
  </opcode>

  <opcode mnemonic="bt" mem="false">
    <return>Branch.None</return>
    <snippet>        cpu.zf(cpu.zf());
        cpu.cf((($op1.get &amp; (1 &lt;&lt; ($op2.get &amp; ($size-1)))) != 0));</snippet>
    <args size="16">Ew;Gw</args>
    <args size="32">Ed;Gd</args>
    <args size="16">Ew;Ib</args>
    <args size="32">Ed;Ib</args>
  </opcode>
  <opcode mnemonic="bt" mem="true">
    <return>Branch.None</return>
    <snippet>        cpu.zf(cpu.zf());
        int bit = 1 &lt;&lt; ($op2.get &amp; ($size-1));
        int offset = (($op2.get &amp; ~($size-1))/8);
        cpu.cf((($op1.getA offset) &amp; bit) != 0));</snippet>
    <args size="16">Ew;Gw</args>
    <args size="32">Ed;Gd</args>
    <args size="16">Ew;Ib</args>
    <args size="32">Ed;Ib</args>
  </opcode>

  <opcode mnemonic="btc" mem="false">
    <return>Branch.None</return>
    <snippet>        int bit = 1 &lt;&lt; ($op2.get &amp; ($size-1));
        cpu.cf = (0 != ($op1.get &amp; bit));
        cpu.flagStatus &amp;= NCF;
        $op1.set$cast($op1.get^bit));</snippet>
    <args size="16">Ew;Ib</args>
    <args size="16">Ew;Gw</args>
    <args size="32">Ed;Ib</args>
    <args size="32">Ed;Gd</args>
  </opcode>
  <opcode mnemonic="btc" mem="true">
    <return>Branch.None</return>
    <snippet>        int bit = 1 &lt;&lt; ($op2.get &amp; ($size-1));
        int offset = (($op2.get &amp; ~($size-1))/8);
        cpu.cf = (0 != ($op1.getA offset) &amp; bit));
        cpu.flagStatus &amp;= NCF;
        $op1.setA offset, $cast($op1.getA offset)^bit));</snippet>
    <args size="16">Ew;Ib</args>
    <args size="16">Ew;Gw</args>
    <args size="32">Ed;Ib</args>
    <args size="32">Ed;Gd</args>
  </opcode>

  <opcode mnemonic="btr" mem="false">
    <return>Branch.None</return>
    <snippet>        int bit = 1 &lt;&lt; ($op2.get &amp; ($size-1));
        cpu.cf = (0 != ($op1.get &amp; bit));
        cpu.flagStatus &amp;= NCF;
        $op1.set$cast($op1.get &amp; ~bit));</snippet>
    <args size="16">Ew;Ib</args>
    <args size="32">Ed;Ib</args>
    <args size="16">Ew;Gw</args>
    <args size="32">Ed;Gd</args>
  </opcode>
  <opcode mnemonic="btr" mem="true">
    <return>Branch.None</return>
    <snippet>        int bit = 1 &lt;&lt; ($op2.get &amp; ($size-1));
        int offset = (($op2.get &amp; ~($size-1))/8);
        cpu.cf = (0 != ($op1.getA offset) &amp; bit));
        cpu.flagStatus &amp;= NCF;
        $op1.setA offset, $cast($op1.getA offset) &amp; ~bit));</snippet>
    <args size="16">Ew;Ib</args>
    <args size="32">Ed;Ib</args>
    <args size="16">Ew;Gw</args>
    <args size="32">Ed;Gd</args>
  </opcode>

  <opcode mnemonic="bts" mem="false">
    <return>Branch.None</return>
    <snippet>        int bit = 1 &lt;&lt; ($op2.get &amp; ($size-1));
        cpu.cf = (0 != ($op1.get &amp; bit));
        cpu.flagStatus &amp;= NCF;
        $op1.set$cast($op1.get | bit));</snippet>
    <args size="16">Ew;Ib</args>
    <args size="32">Ed;Ib</args>
    <args size="16">Ew;Gw</args>
    <args size="32">Ed;Gd</args>
  </opcode>
  <opcode mnemonic="bts" mem="true">
    <return>Branch.None</return>
    <snippet>        int bit = 1 &lt;&lt; ($op2.get &amp; ($size-1));
        int offset = (($op2.get &amp; ~($size-1))/8);
        cpu.cf = (0 != ($op1.getA offset) &amp; bit));
        cpu.flagStatus &amp;= NCF;
        $op1.setA offset, $cast($op1.getA offset) | bit));</snippet>
    <args size="16">Ew;Ib</args>
    <args size="32">Ed;Ib</args>
    <args size="16">Ew;Gw</args>
    <args size="32">Ed;Gd</args>
  </opcode>

  <opcode mnemonic="call_o16">
    <return>Branch.T1</return>
    <snippet>                cpu.eip += blockLength;
        int tmpEip = 0xffff &amp; (cpu.eip + jmp);
        cpu.cs.checkAddress(tmpEip);
        if ((0xffff &amp; cpu.r_sp.get16()) &lt; 2)
	    throw ProcessorException.STACK_SEGMENT_0;
        cpu.push16((short)cpu.eip);
        cpu.eip = tmpEip;</snippet>
    <args size="16">Jw</args>
    <args size="32">Jd</args>
  </opcode>
  <opcode mnemonic="call_o16">
    <return>Branch.Call_Unknown</return>
    <snippet>        cpu.eip += blockLength;
        int tempEIP = $op1.get &amp; 0xffff;
        cpu.cs.checkAddress(tempEIP);
        if ((cpu.r_sp.get16() &lt; 2) &amp;&amp; (cpu.r_sp.get16() > 0))
	    throw ProcessorException.STACK_SEGMENT_0;
        cpu.push16((short)cpu.eip);
        cpu.eip = tempEIP;</snippet>
    <args size="16">Ew</args>
  </opcode>
  <opcode mnemonic="call_o32">
    <return>Branch.T1</return>
    <snippet>                
        cpu.eip += blockLength;
        if ((cpu.r_esp.get32() &lt; 4) &amp;&amp; (cpu.r_esp.get32() > 0))
	    throw ProcessorException.STACK_SEGMENT_0;
        int tmpEip = cpu.eip + jmp;
        cpu.cs.checkAddress(tmpEip);
        cpu.push32(cpu.eip);
        cpu.eip = tmpEip;</snippet>
    <args size="32">Jd</args>
  </opcode>
  <opcode mnemonic="call_o32">
    <return>Branch.Call_Unknown</return>
    <snippet>        cpu.eip += blockLength;
        int target = $op1.get;
        cpu.cs.checkAddress(target);
        if ((cpu.r_esp.get32() &lt; 4) &amp;&amp; (cpu.r_esp.get32() > 0))
	    throw ProcessorException.STACK_SEGMENT_0;
        cpu.push32(cpu.eip);
        cpu.eip = target;</snippet>
    <args size="16">Ew</args>
    <args size="32">Ed</args>
  </opcode>
  <opcode mnemonic="call_o16">
    <return>Branch.Call_Unknown</return>
    <snippet>                cpu.eip += blockLength;
        if (cpu.ss.getDefaultSizeFlag())
            throw new IllegalStateException("pm call far o16 a32 not implemented");
        else
            cpu.call_far_pm_o16_a16(0xffff &amp; cs, 0xffff &amp; targetEip);</snippet>
    <args size="16">Ep</args>
    <args size="16">Ap</args>
  </opcode>
  <opcode mnemonic="call_o32">
    <return>Branch.Call_Unknown</return>
    <snippet>                cpu.eip += blockLength;
        if (!cpu.ss.getDefaultSizeFlag())
            cpu.call_far_pm_o32_a16(0xffff &amp; cs, targetEip);
        else
            cpu.call_far_pm_o32_a32(0xffff &amp; cs, targetEip);</snippet>
    <args size="32">Ep</args>
    <args size="32">Ap</args>
  </opcode>

  <opcode mnemonic="cbw">
    <return>Branch.None</return>
    <snippet>            cpu.r_ax.set16((byte)cpu.r_al.get8());</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="cdq">
    <return>Branch.None</return>
    <snippet>        if (cpu.r_eax.get32() &lt; 0)
            cpu.r_edx.set32(-1);
        else
            cpu.r_edx.set32(0);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="clc">
    <return>Branch.None</return>
    <snippet>        cpu.cf = false;
        cpu.flagStatus &amp;= NCF;</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="cld">
    <return>Branch.None</return>
    <snippet>        cpu.df = false;</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="cli">
    <return>Branch.None</return>
    <snippet>        /* uncomment if we support VME
                        if ((cpu.getCPL() == 3) &amp;&amp; ((cpu.getCR4() &amp; 2) != 0)) {
                            if (cpu.getIOPrivilegeLevel() &lt; 3)
                            {
                               cpu.eflagsInterruptEnableSoon = false;
                               return;
                            }
                        } else
                    */
                    {
                        if (cpu.getIOPrivilegeLevel() &lt; cpu.getCPL())
                        {
                            System.out.println("IOPL=" + cpu.getIOPrivilegeLevel() + ", CPL=" + cpu.getCPL() + "CR4=0x" + Integer.toHexString(cpu.getCR4()));
                            throw new ProcessorException(ProcessorException.Type.GENERAL_PROTECTION, 0, true);
                        }
                    }
                    cpu.eflagsInterruptEnable = false;</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="clts">
    <return>Branch.None</return>
    <snippet>        if (cpu.getCPL() != 0) throw new ProcessorException(ProcessorException.Type.GENERAL_PROTECTION, 0, true);//ProcessorException.GENERAL_PROTECTION_0;
		    cpu.setCR0(cpu.getCR0() &amp; ~0x8);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="cmc">
    <return>Branch.None</return>
    <snippet>        cpu.cf = cpu.cf() ^ true;
        cpu.flagStatus &amp;= NCF;</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="cmova">
    <return>Branch.None</return>
    <snippet>        if (!cpu.cf() &amp;&amp; !cpu.zf())
            $op1.set$cast$op2.get);</snippet>
    <args size="16">Gw;Ew</args>
    <args size="32">Gd;Ed</args>
  </opcode>
  <opcode mnemonic="cmovae">
    <return>Branch.None</return>
    <snippet>        if (!cpu.cf())
            $op1.set$cast$op2.get);</snippet>
    <args size="16">Gw;Ew</args>
    <args size="32">Gd;Ed</args>
  </opcode>
  <opcode mnemonic="cmovb">
    <return>Branch.None</return>
    <snippet>        if (cpu.cf())
            $op1.set$cast$op2.get);</snippet>
    <args size="16">Gw;Ew</args>
    <args size="32">Gd;Ed</args>
  </opcode>
  <opcode mnemonic="cmovbe">
    <return>Branch.None</return>
    <snippet>        if (cpu.cf() || cpu.zf())
            $op1.set$cast$op2.get);</snippet>
    <args size="16">Gw;Ew</args>
    <args size="32">Gd;Ed</args>
  </opcode>
  <opcode mnemonic="cmove">
    <return>Branch.None</return>
    <snippet>        if (cpu.zf())
            $op1.set$cast$op2.get);</snippet>
    <args size="16">Gw;Ew</args>
    <args size="32">Gd;Ed</args>
  </opcode>
  <opcode mnemonic="cmovne">
    <return>Branch.None</return>
    <snippet>        if (!cpu.zf())
            $op1.set$cast$op2.get);</snippet>
    <args size="16">Gw;Ew</args>
    <args size="32">Gd;Ed</args>
  </opcode>
  <opcode mnemonic="cmovg">
    <return>Branch.None</return>
    <snippet>        if (!cpu.zf() &amp;&amp; (cpu.sf() == cpu.of()))
            $op1.set$cast$op2.get);</snippet>
    <args size="16">Gw;Ew</args>
    <args size="32">Gd;Ed</args>
  </opcode>
  <opcode mnemonic="cmovge">
    <return>Branch.None</return>
    <snippet>        if (cpu.sf() == cpu.of())
            $op1.set$cast$op2.get);</snippet>
    <args size="16">Gw;Ew</args>
    <args size="32">Gd;Ed</args>
  </opcode>
  <opcode mnemonic="cmovl">
    <return>Branch.None</return>
    <snippet>        if (cpu.sf() != cpu.of())
            $op1.set$cast$op2.get);</snippet>
    <args size="16">Gw;Ew</args>
    <args size="32">Gd;Ed</args>
  </opcode>
  <opcode mnemonic="cmovle">
    <return>Branch.None</return>
    <snippet>        if (cpu.zf() || (cpu.sf() != cpu.of()))
            $op1.set$cast$op2.get);</snippet>
    <args size="16">Gw;Ew</args>
    <args size="32">Gd;Ed</args>
  </opcode>
  <opcode mnemonic="cmovs">
    <return>Branch.None</return>
    <snippet>        if (cpu.sf())
            $op1.set$cast$op2.get);</snippet>
    <args size="16">Gw;Ew</args>
    <args size="32">Gd;Ed</args>
  </opcode>
  <opcode mnemonic="cmovns">
    <return>Branch.None</return>
    <snippet>        if (!cpu.sf())
            $op1.set$cast$op2.get);</snippet>
    <args size="16">Gw;Ew</args>
    <args size="32">Gd;Ed</args>
  </opcode>

  <opcode mnemonic="cmp">
    <return>Branch.None</return>
    <snippet>        cpu.flagOp1 = $op1.get;
        cpu.flagOp2 = $op2.get;
        cpu.flagResult = $cast(cpu.flagOp1 - cpu.flagOp2);
        cpu.flagIns = UCodes.SUB$size;
        cpu.flagStatus = OSZAPC;</snippet>
    <args size="8">AL;Ib</args>
    <args size="8">Eb;Ib</args>
    <args size="8">Eb;Gb</args>
    <args size="8">Gb;Eb</args>
    <args size="16">Gw;Ew</args>
    <args size="32">Gd;Ed</args>
    <args size="16">Ew;Ib</args>
    <args size="32">Ed;Ib</args>
    <args size="16">Ew;Gw</args>
    <args size="32">Ed;Gd</args>
    <args size="16">Ew;Iw</args>
    <args size="32">Ed;Id</args>
  </opcode>

  <opcode mnemonic="cmp_o16">
    <return>Branch.None</return>
    <snippet>        cpu.flagOp1 = $op1.get;
        cpu.flagOp2 = $op2.get;
        cpu.flagResult = $cast(cpu.flagOp1 - cpu.flagOp2);
        cpu.flagIns = UCodes.SUB$size;
        cpu.flagStatus = OSZAPC;</snippet>
    <args size="16">rAX;Iw</args>
  </opcode>

  <opcode mnemonic="cmp_o32">
    <return>Branch.None</return>
    <snippet>        cpu.flagOp1 = $op1.get;
        cpu.flagOp2 = $op2.get;
        cpu.flagResult = $cast(cpu.flagOp1 - cpu.flagOp2);
        cpu.flagIns = UCodes.SUB$size;
        cpu.flagStatus = OSZAPC;</snippet>
    <args size="32">rAX;Id</args>
  </opcode>

  <opcode mnemonic="cmpxchg">
    <return>Branch.None</return>
    <snippet>        cpu.flagOp1 = cpu.r_eax.get$size();
        cpu.flagOp2 = $op1.get;
        cpu.flagResult = $cast(cpu.flagOp1 - cpu.flagOp2);
        cpu.flagIns = UCodes.SUB$size;
        cpu.flagStatus = OSZAPC;
        if (cpu.flagOp1 == cpu.flagOp2)
        {
            cpu.zf(true);
            $op1.set$op2.get);
        }
        else
        {
            cpu.zf(false);
            cpu.r_eax.set32($op1.get);
        }</snippet>
    <args size="32">Ed;Gd</args>
  </opcode>

  <opcode mnemonic="cpuid">
    <return>Branch.None</return>
    <snippet>        cpu.cpuid();</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="cwd">
    <return>Branch.None</return>
    <snippet>        if ((short)cpu.r_ax.get16() &lt; 0)
            cpu.r_dx.set16((short)-1);
        else
            cpu.r_dx.set16((short)0);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="cwde">
    <return>Branch.None</return>
    <snippet>            cpu.r_eax.set32((short)cpu.r_ax.get16());</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="dec">
    <return>Branch.None</return>
    <snippet>        cpu.cf = Processor.getCarryFlag(cpu.flagStatus, cpu.cf, cpu.flagOp1, cpu.flagOp2, cpu.flagResult, cpu.flagIns);
        cpu.flagOp1 = $op1.get;
        cpu.flagOp2 = 1;
        cpu.flagResult = $cast(cpu.flagOp1 - 1);
        $op1.set$castcpu.flagResult);
        cpu.flagIns = UCodes.SUB$size;
        cpu.flagStatus = NCF;</snippet>
    <args size="8">Eb</args>
    <args size="16">Ew</args>
    <args size="32">Ed</args>
  </opcode>

  <opcode mnemonic="dec_o16">
    <return>Branch.None</return>
    <snippet>        cpu.cf = Processor.getCarryFlag(cpu.flagStatus, cpu.cf, cpu.flagOp1, cpu.flagOp2, cpu.flagResult, cpu.flagIns);
        cpu.flagOp1 = $op1.get;
        cpu.flagOp2 = 1;
        cpu.flagResult = $cast(cpu.flagOp1 - 1);
        $op1.set$castcpu.flagResult);
        cpu.flagIns = UCodes.SUB$size;
        cpu.flagStatus = NCF;</snippet>
    <args size="16">eAX</args>
    <args size="16">eBX</args>
    <args size="16">eCX</args>
    <args size="16">eDX</args>
    <args size="16">eSI</args>
    <args size="16">eDI</args>
    <args size="16">eSP</args>
    <args size="16">eBP</args>
  </opcode>

  <opcode mnemonic="dec_o32">
    <return>Branch.None</return>
    <snippet>        cpu.cf = Processor.getCarryFlag(cpu.flagStatus, cpu.cf, cpu.flagOp1, cpu.flagOp2, cpu.flagResult, cpu.flagIns);
        cpu.flagOp1 = $op1.get;
        cpu.flagOp2 = 1;
        cpu.flagResult = $cast(cpu.flagOp1 - 1);
        $op1.setcpu.flagResult);
        cpu.flagIns = UCodes.SUB$size;
        cpu.flagStatus = NCF;</snippet>
    <args size="32">eAX</args>
    <args size="32">eBX</args>
    <args size="32">eCX</args>
    <args size="32">eDX</args>
    <args size="32">eSI</args>
    <args size="32">eDI</args>
    <args size="32">eSP</args>
    <args size="32">eBP</args>
  </opcode>

  <opcode mnemonic="div">
    <return>Branch.None</return>
    <snippet>        if ($op1.get == 0)
            throw ProcessorException.DIVIDE_ERROR;
        int ldiv = cpu.r_ax.get16();
        cpu.r_al.set$size($cast (ldiv/($mask $op1.get)));
        cpu.r_ah.set$size($cast (ldiv % ($mask $op1.get)));</snippet>
    <args size="8">Eb</args>
  </opcode>

  <opcode mnemonic="div">
    <return>Branch.None</return>
    <snippet>        if ($op1.get == 0)
            throw ProcessorException.DIVIDE_ERROR;
        long ldiv = (((long)cpu.r_edx.get$size()) &lt;&lt; $size ) | ($mask cpu.r_eax.get$size());
        cpu.r_eax.set$size($cast (ldiv/($mask $op1.get)));
        cpu.r_edx.set$size($cast (ldiv % ($mask $op1.get)));</snippet>
    <args size="16">Ew</args>
  </opcode>
  <opcode mnemonic="div">
    <return>Branch.None</return>
    <snippet>        if ($op1.get == 0)
            throw ProcessorException.DIVIDE_ERROR;
        long ldiv = (((long)cpu.r_edx.get$size()) &lt;&lt; $size ) | (0xffffffffL &amp; cpu.r_eax.get$size());
        cpu.r_eax.set$size($cast (ldiv/(0xffffffffL &amp; $op1.get)));
        cpu.r_edx.set$size($cast (ldiv % (0xffffffffL &amp; $op1.get)));</snippet>
    <args size="32">Ed</args>
  </opcode>

  <opcode mnemonic="emms">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.setTagWord(0xffff);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="enter_o16">
    <return>Branch.None</return>
    <snippet>            int frameSize = $op1.get;
        int nestingLevel = $op2.get;
        nestingLevel %= 32;

        int frameTemp;
        if (cpu.ss.getDefaultSizeFlag())
        {
            cpu.push16((short)cpu.r_bp.get16());
            frameTemp = cpu.r_esp.get32();
        }
        else
        {
            cpu.push16((short)cpu.r_bp.get16());
            frameTemp = cpu.r_esp.get16();
        }

	if (nestingLevel != 0) {
	    while (--nestingLevel != 0) {
                if (cpu.ss.getDefaultSizeFlag())
                    cpu.push16(cpu.ss.getWord(cpu.r_ebp.get32()));
                else
                    cpu.push16(cpu.ss.getWord(cpu.r_ebp.get16() &amp; 0xffff));
		//tempEBP = (tempEBP &amp; ~0xffff) | ((tempEBP - 2) &amp; 0xffff);
		//tempESP = (tempESP &amp; ~0xffff) | ((tempESP - 2) &amp; 0xffff);
		//cpu.ss.setWord(tempESP &amp; 0xffff, cpu.ss.getWord(tempEBP &amp; 0xffff));
	    }
	    cpu.push16((short)frameTemp);
	}
	
	if (cpu.ss.getDefaultSizeFlag())
        {
            cpu.r_ebp.set32(frameTemp);
            cpu.r_esp.set32(cpu.r_esp.get32()-frameSize);
        }
        else
        {
            cpu.r_bp.set16((short)frameTemp);
            cpu.r_sp.set16((short)(cpu.r_sp.get16()-frameSize));
        }</snippet>
    <args size="16">Iw;Ib</args>
  </opcode>

  <opcode mnemonic="enter_o32">
    <return>Branch.None</return>
    <snippet>            int frameSize = $op1.get;
        int nestingLevel = $op2.get;
        if (cpu.ss.getDefaultSizeFlag())
            cpu.enter_o32_a32(frameSize, nestingLevel);
        else
            throw new IllegalStateException("PM enter o32 a16 unimplemented");</snippet>
    <args size="16">Iw;Ib</args>
  </opcode>

  <opcode mnemonic="fabs">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.setST(0, Math.abs(cpu.fpu.ST(0)));</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fadd">
    <return>Branch.None</return>
    <snippet>        double freg0 = cpu.fpu.ST(0);
        double freg1 = $op1.getF;
        if ((freg0 == Double.NEGATIVE_INFINITY &amp;&amp; freg1 == Double.POSITIVE_INFINITY) || (freg0 == Double.POSITIVE_INFINITY &amp;&amp; freg1 == Double.NEGATIVE_INFINITY))
            cpu.fpu.setInvalidOperation();
	if ((freg1 == 0.0) &amp;&amp; !Double.isNaN(freg0) &amp;&amp; !Double.isInfinite(freg0))
            cpu.fpu.setZeroDivide();
        cpu.fpu.setST(0, freg0+freg1);</snippet>
    <args size="32">Md</args>
    <args size="64">Mq</args>
  </opcode>

  <opcode mnemonic="fadd">
    <return>Branch.None</return>
    <snippet>        double freg0 = $op1.get;
        double freg1 = $op2.get;
        if ((freg0 == Double.NEGATIVE_INFINITY &amp;&amp; freg1 == Double.POSITIVE_INFINITY) || (freg0 == Double.POSITIVE_INFINITY &amp;&amp; freg1 == Double.NEGATIVE_INFINITY))
            cpu.fpu.setInvalidOperation();
	if ((freg1 == 0.0) &amp;&amp; !Double.isNaN(freg0) &amp;&amp; !Double.isInfinite(freg0))
            cpu.fpu.setZeroDivide();
        $op1.setfreg0+freg1);</snippet>
    <args size="64">STi;STi</args>
  </opcode>

  <opcode mnemonic="faddp">
    <return>Branch.None</return>
    <snippet>        double freg0 = $op1.get;
        double freg1 = $op2.get;
        if ((freg0 == Double.NEGATIVE_INFINITY &amp;&amp; freg1 == Double.POSITIVE_INFINITY) || (freg0 == Double.POSITIVE_INFINITY &amp;&amp; freg1 == Double.NEGATIVE_INFINITY))
            cpu.fpu.setInvalidOperation();
	if ((freg1 == 0.0) &amp;&amp; !Double.isNaN(freg0) &amp;&amp; !Double.isInfinite(freg0))
            cpu.fpu.setZeroDivide();
        $op1.setfreg0+freg1);
        cpu.fpu.pop();</snippet>
    <args size="64">STi;STi</args>
  </opcode>

  <opcode mnemonic="fchs">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.setST(0, -cpu.fpu.ST(0));</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fcomp">
    <return>Branch.None</return>
    <snippet>                            int newcode = 0xd;
        double freg0 = cpu.fpu.ST(0);
        double freg1 = $op1.getF;
        if (Double.isNaN(freg0) || Double.isNaN(freg1))
            cpu.fpu.setInvalidOperation();
        else {
            if (freg0 > freg1) newcode = 0;
            else if (freg0 &lt; freg1) newcode = 1;
            else newcode = 8;
        }
        cpu.fpu.conditionCode &amp;= 2;
        cpu.fpu.conditionCode |= newcode;
        cpu.fpu.pop();</snippet>
    <args size="32">Md</args>
    <args size="64">Mq</args>
  </opcode>
  <opcode mnemonic="fcompp">
    <return>Branch.None</return>
    <snippet>                            int newcode = 0xd;
        double freg0 = cpu.fpu.ST(0);
        double freg1 = cpu.fpu.ST(1);
        if (Double.isNaN(freg0) || Double.isNaN(freg1))
            cpu.fpu.setInvalidOperation();
        else {
            if (freg0 > freg1) newcode = 0;
            else if (freg0 &lt; freg1) newcode = 1;
            else newcode = 8;
        }
        cpu.fpu.conditionCode &amp;= 2;
        cpu.fpu.conditionCode |= newcode;
        cpu.fpu.pop();
        cpu.fpu.pop();</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fcos">
    <return>Branch.None</return>
    <snippet>        double freg0 = cpu.fpu.ST(0);
        if (Double.isInfinite(freg0))
	    cpu.fpu.setInvalidOperation();
        if ((freg0 > Long.MAX_VALUE) || (freg0 &lt; Long.MIN_VALUE))
	    cpu.fpu.conditionCode |= 4; // set C2
        else
            cpu.fpu.setST(0, Math.cos(freg0));</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fdiv">
    <return>Branch.None</return>
    <snippet>        double freg0 = cpu.fpu.ST(0);
        double freg1 = $op1.getF;
        if (((freg0 == 0.0) &amp;&amp; (freg1 == 0.0)) || (Double.isInfinite(freg0) &amp;&amp; Double.isInfinite(freg1)))
            cpu.fpu.setInvalidOperation();
	if ((freg1 == 0.0) &amp;&amp; !Double.isNaN(freg0) &amp;&amp; !Double.isInfinite(freg0))
            cpu.fpu.setZeroDivide();
        cpu.fpu.setST(0, freg0/freg1);</snippet>
    <args size="32">Md</args>
    <args size="64">Mq</args>
  </opcode>

  <opcode mnemonic="fdivp">
    <return>Branch.None</return>
    <snippet>        double freg0 = $op1.get;
        double freg1 = $op2.get;
        if (((freg0 == 0.0) &amp;&amp; (freg1 == 0.0)) || (Double.isInfinite(freg0) &amp;&amp; Double.isInfinite(freg1)))
            cpu.fpu.setInvalidOperation();
	if ((freg1 == 0.0) &amp;&amp; !Double.isNaN(freg0) &amp;&amp; !Double.isInfinite(freg0))
            cpu.fpu.setZeroDivide();
        $op1.setfreg0/freg1);
        cpu.fpu.pop();</snippet>
    <args size="64">STi;STi</args>
  </opcode>

  <opcode mnemonic="fdivr">
    <return>Branch.None</return>
    <snippet>        double freg0 = cpu.fpu.ST(0);
        double freg1 = $op1.getF;
        if (((freg0 == 0.0) &amp;&amp; (freg1 == 0.0)) || (Double.isInfinite(freg0) &amp;&amp; Double.isInfinite(freg1)))
            cpu.fpu.setInvalidOperation();
	if ((freg0 == 0.0) &amp;&amp; !Double.isNaN(freg1) &amp;&amp; !Double.isInfinite(freg1))
            cpu.fpu.setZeroDivide();
        cpu.fpu.setST(0, freg1/freg0);</snippet>
    <args size="32">Md</args>
    <args size="64">Mq</args>
  </opcode>
  <opcode mnemonic="fdivr">
    <return>Branch.None</return>
    <snippet>        double freg0 = $op1.get;
        double freg1 = $op2.get;
        if (((freg0 == 0.0) &amp;&amp; (freg1 == 0.0)) || (Double.isInfinite(freg0) &amp;&amp; Double.isInfinite(freg1)))
            cpu.fpu.setInvalidOperation();
	if ((freg0 == 0.0) &amp;&amp; !Double.isNaN(freg1) &amp;&amp; !Double.isInfinite(freg1))
            cpu.fpu.setZeroDivide();
        $op1.setfreg1/freg0);</snippet>
    <args size="64">STi;STi</args>
  </opcode>

  <opcode mnemonic="fdivrp">
    <return>Branch.None</return>
    <snippet>        double freg0 = $op1.get;
        double freg1 = $op2.get;
        if (((freg0 == 0.0) &amp;&amp; (freg1 == 0.0)) || (Double.isInfinite(freg0) &amp;&amp; Double.isInfinite(freg1)))
            cpu.fpu.setInvalidOperation();
	if ((freg0 == 0.0) &amp;&amp; !Double.isNaN(freg1) &amp;&amp; !Double.isInfinite(freg1))
            cpu.fpu.setZeroDivide();
        $op1.setfreg1/freg0);
        cpu.fpu.pop();</snippet>
    <args size="64">STi;STi</args>
  </opcode>

  <opcode mnemonic="fild">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.push((double)$op1.get);</snippet>
    <args size="16">Mw</args>
    <args size="32">Md</args>
    <args size="64">Mq</args>
  </opcode>

  <opcode mnemonic="fistp">
    <return>Branch.None</return>
    <snippet>        $op1.set(long)cpu.fpu.ST(0));
        cpu.fpu.pop();</snippet>
    <args size="64">Mq</args>
  </opcode>
  <opcode mnemonic="fistp">
    <return>Branch.None</return>
    <snippet>        $op1.set(int)cpu.fpu.ST(0));
        cpu.fpu.pop();</snippet>
    <args size="32">Md</args>
  </opcode>

  <opcode mnemonic="wait">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.checkExceptions();</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fld">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.push($op1.getF);</snippet>
    <args size="32">Md</args>
    <args size="64">Mq</args>
  </opcode>

  <opcode mnemonic="fld">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.push($op2.get);</snippet>
    <args size="64">ST0;STi</args>
  </opcode>

  <opcode mnemonic="fld1">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.push(1.0);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fldcw">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.setControl($op1.get);</snippet>
    <args size="16">Mw</args>
  </opcode>

  <opcode mnemonic="fldln2">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.push(Math.log(2));</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fldz">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.push(0.0);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fmul">
    <return>Branch.None</return>
    <snippet>        double freg0 = cpu.fpu.ST(0);
        double freg1 = $op1.getF;
        if ((Double.isInfinite(freg0) &amp;&amp; (freg1 == 0.0)) || (Double.isInfinite(freg1) &amp;&amp; (freg0 == 0.0))) 
            cpu.fpu.setInvalidOperation();
        cpu.fpu.setST(0, freg0*freg1);</snippet>
    <args size="32">Md</args>
    <args size="64">Mq</args>
  </opcode>
  <opcode mnemonic="fmul">
    <return>Branch.None</return>
    <snippet>        double freg0 = $op1.get;
        double freg1 = $op2.get;
        if ((Double.isInfinite(freg0) &amp;&amp; (freg1 == 0.0)) || (Double.isInfinite(freg1) &amp;&amp; (freg0 == 0.0))) 
            cpu.fpu.setInvalidOperation();
        $op1.setfreg0*freg1);</snippet>
    <args size="64">STi;STi</args>
  </opcode>
  <opcode mnemonic="fmulp">
    <return>Branch.None</return>
    <snippet>        double freg0 = $op1.get;
        double freg1 = $op2.get;
        if ((Double.isInfinite(freg0) &amp;&amp; (freg1 == 0.0)) || (Double.isInfinite(freg1) &amp;&amp; (freg0 == 0.0))) 
            cpu.fpu.setInvalidOperation();
        $op1.setfreg0*freg1);
        cpu.fpu.pop();</snippet>
    <args size="64">STi;STi</args>
  </opcode>

  <opcode mnemonic="fninit">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.init();</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fnstcw">
    <return>Branch.None</return>
    <snippet>        $op1.set$castcpu.fpu.getControl());</snippet>
    <args size="16">AX</args>
    <args size="16">Mw</args>
  </opcode>

  <opcode mnemonic="fnstsw">
    <return>Branch.None</return>
    <snippet>        $op1.set$castcpu.fpu.getStatus());</snippet>
    <args size="16">AX</args>
    <args size="16">Mw</args>
  </opcode>

  <opcode mnemonic="fprem">
    <return>Branch.None</return>
    <snippet>        double freg0 = cpu.fpu.ST(0);
        double freg1 = cpu.fpu.ST(1);
        int d = Math.getExponent(freg0) - Math.getExponent(freg1);
        if (d &lt; 64)
        {
            // full remainder
            cpu.fpu.conditionCode &amp;= ~4; // clear C2
            freg0 = freg0 % freg1;
            // compute least significant bits -> C0 C3 C1
            long i = (long)Math.rint(freg0 / freg1);
            cpu.fpu.conditionCode &amp;= 4;
            if ((i &amp; 1) != 0) cpu.fpu.conditionCode |= 2;
            if ((i &amp; 2) != 0) cpu.fpu.conditionCode |= 8;
            if ((i &amp; 4) != 0) cpu.fpu.conditionCode |= 1;
        }
        else
        {
            // partial remainder
            cpu.fpu.conditionCode |= 4; // set C2
            int n = 63; // implementation dependent in manual
            double f = Math.pow(2.0, (double)(d - n));
            double z = (freg0 / freg1) / f;
            double qq = (z &lt; 0) ? Math.ceil(z) : Math.floor(z);
            freg0 = freg0 - (freg1 * qq * f);
        }
        cpu.fpu.setST(0, freg0);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fptan">
    <return>Branch.None</return>
    <snippet>        double freg0 = cpu.fpu.ST(0);
        if ((freg0 > Math.pow(2.0, 63.0)) || (freg0 &lt; -1.0*Math.pow(2.0, 63.0))) {
            if (Double.isInfinite(freg0))
                cpu.fpu.setInvalidOperation();
            cpu.fpu.conditionCode |= 4;
        } else 
        {
            cpu.fpu.conditionCode &amp;= ~4;
            cpu.fpu.setST(0, Math.tan(freg0));
        }</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="frndint">
    <return>Branch.None</return>
    <snippet>        double freg0 = cpu.fpu.ST(0);
        if (!Double.isInfinite(freg0)) // preserve infinities
        {
            switch(cpu.fpu.getRoundingControl())
            {
                case FpuState.FPU_ROUNDING_CONTROL_EVEN:
                    cpu.fpu.setST(0, Math.rint(freg0));
                    break;
                case FpuState.FPU_ROUNDING_CONTROL_DOWN:
                    cpu.fpu.setST(0, Math.floor(freg0));
                    break;
                case FpuState.FPU_ROUNDING_CONTROL_UP:
                    cpu.fpu.setST(0, Math.ceil(freg0));
                    break;
                case FpuState.FPU_ROUNDING_CONTROL_TRUNCATE:
                    cpu.fpu.setST(0, Math.signum(freg0) * Math.floor(Math.abs(freg0)));
                    break;
                default:
                    throw new IllegalStateException("Invalid rounding control value");
            }
        }
</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fsetpm">
    <return>Branch.None</return>
    <snippet></snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fsin">
    <return>Branch.None</return>
    <snippet>        double freg0 = cpu.fpu.ST(0);
        if (Double.isInfinite(freg0))
	    cpu.fpu.setInvalidOperation();
        if ((freg0 > Long.MAX_VALUE) || (freg0 &lt; Long.MIN_VALUE))
	    cpu.fpu.conditionCode |= 4; // set C2
        else
            cpu.fpu.setST(0, Math.sin(freg0));</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fst">
    <return>Branch.None</return>
    <snippet>        $op1.setF(float)cpu.fpu.ST(0));</snippet>
    <args size="32">Md</args>
  </opcode>
  <opcode mnemonic="fst">
    <return>Branch.None</return>
    <snippet>        $op1.setFcpu.fpu.ST(0));</snippet>
    <args size="64">Mq</args>
  </opcode>

  <opcode mnemonic="fstp">
    <return>Branch.None</return>
    <snippet>        $op1.setF(float)cpu.fpu.ST(0));
        cpu.fpu.pop();</snippet>
    <args size="32">Md</args>
  </opcode>
  <opcode mnemonic="fstp">
    <return>Branch.None</return>
    <snippet>        $op1.setFcpu.fpu.ST(0));
        cpu.fpu.pop();</snippet>
    <args size="64">Mq</args>
  </opcode>
  <opcode mnemonic="fstp">
    <return>Branch.None</return>
    <snippet>        $op1.setcpu.fpu.ST(0));
        cpu.fpu.pop();</snippet>
    <args size="64">STi</args>
  </opcode>

  <opcode mnemonic="fsqrt">
    <return>Branch.None</return>
    <snippet>        if (cpu.fpu.ST(0) &lt; 0)
			cpu.fpu.setInvalidOperation();
        cpu.fpu.setST(0, Math.sqrt(cpu.fpu.ST(0)));</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fsub">
    <return>Branch.None</return>
    <snippet>        double freg0 = cpu.fpu.ST(0);
        double freg1 = $op1.getF;
        if ((freg0 == Double.NEGATIVE_INFINITY &amp;&amp; freg1 == Double.NEGATIVE_INFINITY) || (freg0 == Double.POSITIVE_INFINITY &amp;&amp; freg1 == Double.POSITIVE_INFINITY)) 
		    cpu.fpu.setInvalidOperation();
        $op1.setFfreg0-freg1);</snippet>
    <args size="64">Mq</args>
  </opcode>

  <opcode mnemonic="fsubr">
    <return>Branch.None</return>
    <snippet>        double freg0 = cpu.fpu.ST(0);
        double freg1 = $op1.getF;
        if ((freg0 == Double.NEGATIVE_INFINITY &amp;&amp; freg1 == Double.NEGATIVE_INFINITY) || (freg0 == Double.POSITIVE_INFINITY &amp;&amp; freg1 == Double.POSITIVE_INFINITY)) 
		    cpu.fpu.setInvalidOperation();
        cpu.fpu.setST(0, freg1-freg0);</snippet>
    <args size="64">Mq</args>
  </opcode>
  <opcode mnemonic="fsubrp">
    <return>Branch.None</return>
    <snippet>        double freg0 = $op1.get;
        double freg1 = $op1.get;
        if ((freg0 == Double.NEGATIVE_INFINITY &amp;&amp; freg1 == Double.NEGATIVE_INFINITY) || (freg0 == Double.POSITIVE_INFINITY &amp;&amp; freg1 == Double.POSITIVE_INFINITY)) 
		    cpu.fpu.setInvalidOperation();
        $op1.set freg1-freg0);
        cpu.fpu.pop();</snippet>
    <args size="64">STi;STi</args>
  </opcode>

  <opcode mnemonic="fucom">
    <return>Branch.None</return>
    <snippet>        int newcode = 0xd;
        double freg0 = cpu.fpu.ST(0);
        double freg1 = $op1.get;
        if (!(Double.isNaN(freg0) || Double.isNaN(freg1)))
        {
            if (freg0 > freg1) newcode = 0;
            else if (freg0 &lt; freg1) newcode = 1;
            else newcode = 8;
        }
        cpu.fpu.conditionCode &amp;= 2;
        cpu.fpu.conditionCode |= newcode;</snippet>
    <args size="64">STi</args>
  </opcode>

  <opcode mnemonic="fucomp">
    <return>Branch.None</return>
    <snippet>        int newcode = 0xd;
        double freg0 = cpu.fpu.ST(0);
        double freg1 = $op1.get;
        if (!(Double.isNaN(freg0) || Double.isNaN(freg1)))
        {
            if (freg0 > freg1) newcode = 0;
            else if (freg0 &lt; freg1) newcode = 1;
            else newcode = 8;
        }
        cpu.fpu.conditionCode &amp;= 2;
        cpu.fpu.conditionCode |= newcode;
        cpu.fpu.pop();</snippet>
    <args size="64">STi</args>
  </opcode>

  <opcode mnemonic="fucompp">
    <return>Branch.None</return>
    <snippet>        int newcode = 0xd;
        double freg0 = cpu.fpu.ST(0);
        double freg1 = $op1.get;
        if (!(Double.isNaN(freg0) || Double.isNaN(freg1)))
        {
            if (freg0 > freg1) newcode = 0;
            else if (freg0 &lt; freg1) newcode = 1;
            else newcode = 8;
        }
        cpu.fpu.conditionCode &amp;= 2;
        cpu.fpu.conditionCode |= newcode;
        cpu.fpu.pop();
        cpu.fpu.pop();</snippet>
    <args size="64">STi</args>
  </opcode>

  <opcode mnemonic="fucompp">
    <return>Branch.None</return>
    <snippet>        int newcode = 0xd;
        double freg0 = cpu.fpu.ST(0);
        double freg1 = cpu.fpu.ST(1);
        if (!(Double.isNaN(freg0) || Double.isNaN(freg1)))
        {
            if (freg0 > freg1) newcode = 0;
            else if (freg0 &lt; freg1) newcode = 1;
            else newcode = 8;
        }
        cpu.fpu.conditionCode &amp;= 2;
        cpu.fpu.conditionCode |= newcode;
        cpu.fpu.pop();
        cpu.fpu.pop();</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fxch">
    <return>Branch.None</return>
    <snippet>        double tmp = $op1.get;
        $op1.set$op2.get);
        $op2.settmp);</snippet>
    <args size="64">STi;STi</args>
  </opcode>

  <opcode mnemonic="hlt">
    <return>Branch.Jmp_Unknown</return>
    <snippet>            cpu.eip += blockLength;
        if (cpu.getCPL() != 0)
            throw new ProcessorException(ProcessorException.Type.GENERAL_PROTECTION, 0, true);
        else
            cpu.waitForInterrupt();</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="idiv">
    <return>Branch.None</return>
    <snippet>        if ($op1.get == 0)
            throw ProcessorException.DIVIDE_ERROR;
        short ldiv = (short)cpu.r_ax.get16();
        cpu.r_al.set$size($cast(ldiv/$cast$op1.get));
        cpu.r_ah.set$size($cast(ldiv % $cast$op1.get));</snippet>
    <args size="8">Eb</args>
  </opcode>
  <opcode mnemonic="idiv">
    <return>Branch.None</return>
    <snippet>        if ($op1.get == 0)
            throw ProcessorException.DIVIDE_ERROR;
        long ldiv = (((long)($maskcpu.r_edx.get$size())) &lt;&lt; $size ) | ($maskcpu.r_eax.get$size());
        cpu.r_eax.set$size($cast(int)(ldiv/$cast$op1.get));
        cpu.r_edx.set$size($cast(int)(ldiv % $cast$op1.get));</snippet>
    <args size="16">Ew</args>
  </opcode>
  <opcode mnemonic="idiv">
    <return>Branch.None</return>
    <snippet>        if ($op1.get == 0)
            throw ProcessorException.DIVIDE_ERROR;
        long ldiv = (((0xffffffffL &amp; cpu.r_edx.get$size())) &lt;&lt; $size ) | (0xffffffffL &amp; cpu.r_eax.get$size());
        cpu.r_eax.set$size($cast(int)(ldiv/$cast$op1.get));
        cpu.r_edx.set$size($cast(int)(ldiv % $cast$op1.get));</snippet>
    <args size="32">Ed</args>
  </opcode>


  <opcode mnemonic="imul">
    <return>Branch.None</return>
    <snippet>            cpu.flagStatus = OSZAPC;
            cpu.flagOp1 = $cast$op1.get;
            cpu.flagOp2 = $castcpu.r_eax.get$size();
            long res64 = cpu.flagOp1 * cpu.flagOp2;
            cpu.flagResult = (short) res64;
            cpu.r_eax.set16(cpu.flagResult);
            cpu.flagIns = UCodes.IMUL$size;
            if (res64 &lt; 0)
                cpu.sf(true);
            else
                cpu.sf(false);
            </snippet>
    <args size="8">Eb</args>
  </opcode>
  <opcode mnemonic="imul">
    <return>Branch.None</return>
    <snippet>            cpu.flagStatus = OSZAPC;
            cpu.flagOp1 = $cast$op1.get;
            cpu.flagOp2 = $castcpu.r_eax.get$size();
            long res64 = (((long) cpu.flagOp1)*cpu.flagOp2);
            cpu.flagResult = (int) res64;
            cpu.r_eax.set$size($castcpu.flagResult);
            cpu.r_edx.set$size($cast(int)(res64 >> $size));
            cpu.flagIns = UCodes.IMUL$size;
            if (res64 &lt; 0)
                cpu.sf(true);
            else
                cpu.sf(false);
            if (res64 == cpu.flagResult)
            {
                cpu.of(false);
                cpu.cf(false);
            } else
            {
                cpu.of(true);
                cpu.cf(true);
            }</snippet>
    <args size="16">Ew</args>
    <args size="32">Ed</args>
  </opcode>

  <opcode mnemonic="imul">
    <return>Branch.None</return>
    <snippet>            cpu.flagStatus = OSZAPC;
            cpu.flagOp1 = $cast$op1.get;
            cpu.flagOp2 = $cast$op2.get;
            long res64 = (((long) cpu.flagOp1)*cpu.flagOp2);
            cpu.flagResult = $cast(int) res64;
            $op1.set$castcpu.flagResult);
            cpu.flagIns = UCodes.IMUL$size;
            if (res64 == cpu.flagResult)
            {
                cpu.of(false);
                cpu.cf(false);
            } else
            {
                cpu.of(true);
                cpu.cf(true);
            }
            if (res64 &lt; 0)
                cpu.sf(true);
            else
                cpu.sf(false);</snippet>
    <args size="16">Gw;Ew</args>
    <args size="32">Gd;Ed</args>
  </opcode>

  <opcode mnemonic="imul">
    <return>Branch.None</return>
    <snippet>            cpu.flagStatus = OSZAPC;
            cpu.flagOp1 = $cast$op3.get;
            cpu.flagOp2 = $cast$op2.get;
            long res64 = (((long) cpu.flagOp1)*cpu.flagOp2);
            cpu.flagResult = $cast(int) res64;
            $op1.set$castcpu.flagResult);
            cpu.flagIns = UCodes.IMUL$size;
            if (res64 == cpu.flagResult)
            {
                cpu.of(false);
                cpu.cf(false);
            } else
            {
                cpu.of(true);
                cpu.cf(true);
            }
            if (res64 &lt; 0)
                cpu.sf(true);
            else
                cpu.sf(false);</snippet>
    <args size="16">Gw;Ew;Ib</args>
    <args size="16">Gw;Ew;Iw</args>
    <args size="32">Gd;Ed;Ib</args>
    <args size="32">Gd;Ed;Id</args>
  </opcode>

  <opcode mnemonic="in">
    <return>Branch.None</return>
    <snippet>        if (cpu.checkIOPermissions8($mask2$op2.get))
            $op1.setcpu.ioports.ioPortRead8($mask2$op2.get));
        else
            throw ProcessorException.GENERAL_PROTECTION_0;</snippet>
    <args size="8">AL;Ib</args>
    <args size="8">AL;DX</args>
  </opcode>
  <opcode mnemonic="in_o16">
    <return>Branch.None</return>
    <snippet>        if (cpu.checkIOPermissions16($mask2$op2.get))
            $op1.setcpu.ioports.ioPortRead16($mask2$op2.get));
        else
            throw ProcessorException.GENERAL_PROTECTION_0;</snippet>
    <args size="16">eAX;DX</args>
  </opcode>
  <opcode mnemonic="in_o32">
    <return>Branch.None</return>
    <snippet>        if (cpu.checkIOPermissions32($mask2$op2.get))
            $op1.setcpu.ioports.ioPortRead32($mask2$op2.get));
        else
            throw ProcessorException.GENERAL_PROTECTION_0;</snippet>
    <args size="32">eAX;DX</args>
  </opcode>

  <opcode mnemonic="inc">
    <return>Branch.None</return>
    <snippet>        cpu.cf = Processor.getCarryFlag(cpu.flagStatus, cpu.cf, cpu.flagOp1, cpu.flagOp2, cpu.flagResult, cpu.flagIns);
        cpu.flagOp1 = $cast$op1.get;
        cpu.flagOp2 = 1;
        cpu.flagResult = $cast(cpu.flagOp1 + 1);
        $op1.set$castcpu.flagResult);
        cpu.flagIns = UCodes.ADD$size;
        cpu.flagStatus = NCF;</snippet>
    <args size="8">Eb</args>
    <args size="16">Ew</args>
    <args size="32">Ed</args>
  </opcode>

  <opcode mnemonic="inc_o16">
    <return>Branch.None</return>
    <snippet>        cpu.cf = Processor.getCarryFlag(cpu.flagStatus, cpu.cf, cpu.flagOp1, cpu.flagOp2, cpu.flagResult, cpu.flagIns);
        cpu.flagOp1 = $cast$op1.get;
        cpu.flagOp2 = 1;
        cpu.flagResult = $cast(cpu.flagOp1 + 1);
        $op1.set$castcpu.flagResult);
        cpu.flagIns = UCodes.ADD$size;
        cpu.flagStatus = NCF;</snippet>
    <args size="16">eAX</args>
    <args size="16">eBX</args>
    <args size="16">eCX</args>
    <args size="16">eDX</args>
    <args size="16">eSP</args>
    <args size="16">eBP</args>
    <args size="16">eSI</args>
    <args size="16">eDI</args>
  </opcode>

  <opcode mnemonic="inc_o32">
    <return>Branch.None</return>
    <snippet>        cpu.cf = Processor.getCarryFlag(cpu.flagStatus, cpu.cf, cpu.flagOp1, cpu.flagOp2, cpu.flagResult, cpu.flagIns);
        cpu.flagOp1 = $cast$op1.get;
        cpu.flagOp2 = 1;
        cpu.flagResult = $cast(cpu.flagOp1 + 1);
        $op1.set$castcpu.flagResult);
        cpu.flagIns = UCodes.ADD$size;
        cpu.flagStatus = NCF;</snippet>
    <args size="32">eAX</args>
    <args size="32">eBX</args>
    <args size="32">eCX</args>
    <args size="32">eDX</args>
    <args size="32">eSP</args>
    <args size="32">eBP</args>
    <args size="32">eSI</args>
    <args size="32">eDI</args>
  </opcode>

  <opcode mnemonic="int">
    <return>Branch.Jmp_Unknown</return>
    <snippet>        cpu.eip += blockLength;
        cpu.handleSoftProtectedModeInterrupt($mask$op1.get, instructionLength);</snippet>
    <args size="8">Ib</args>
  </opcode>

  <opcode mnemonic="int3">
    <return>Branch.Jmp_Unknown</return>
    <snippet>        cpu.eip += blockLength;
        cpu.handleSoftProtectedModeInterrupt(3, instructionLength);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="into">
    <return>Branch.Jmp_Unknown</return>
    <snippet>        cpu.eip += blockLength;
        if (cpu.of())
            cpu.handleSoftProtectedModeInterrupt(4, instructionLength);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="invlpg">
    <return>Branch.None</return>
    <snippet>        if (cpu.getCPL() != 0) throw new ProcessorException(ProcessorException.Type.GENERAL_PROTECTION, 0, true);//ProcessorException.GENERAL_PROTECTION_0;
		    cpu.linearMemory.invalidateTLBEntry($op1.get);</snippet>
    <args size="32">M</args>
  </opcode>

  <opcode mnemonic="iretw">
    <return>Branch.Ret</return>
    <snippet>        if (cpu.ss.getDefaultSizeFlag())
            throw new IllegalStateException("Implement iret_pm_o16_a32");
        else
            cpu.setEFlags(cpu.iret_pm_o16_a16());</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="iretd">
    <return>Branch.Ret</return>
    <snippet>        if (cpu.ss.getDefaultSizeFlag())
            cpu.setEFlags(cpu.iret_pm_o32_a32());
        else
            cpu.setEFlags(cpu.iret_pm_o32_a16());</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="je">
    <return></return>
    <snippet>        if (cpu.zf())
</snippet>
<jcc/>
    <args size="8">Jb</args>
    <args size="16">Jw</args>
    <args size="32">Jd</args>
  </opcode>
  <opcode mnemonic="jne">
    <return></return>
    <snippet>        if (!cpu.zf())
</snippet>
<jcc/>
    <args size="8">Jb</args>
    <args size="16">Jw</args>
    <args size="32">Jd</args>
  </opcode>
  <opcode mnemonic="jl">
    <return></return>
    <snippet>        if (cpu.sf() != cpu.of())
</snippet>
<jcc/>
    <args size="8">Jb</args>
    <args size="16">Jw</args>
    <args size="32">Jd</args>
  </opcode>
  <opcode mnemonic="jle">
    <return></return>
    <snippet>        if (cpu.zf() || (cpu.sf() != cpu.of()))
</snippet>
<jcc/>
    <args size="8">Jb</args>
    <args size="16">Jw</args>
    <args size="32">Jd</args>
  </opcode>
  <opcode mnemonic="jb">
    <return></return>
    <snippet>        if (cpu.cf())
    </snippet>
    <jcc/>
    <args size="8">Jb</args>
    <args size="16">Jw</args>
    <args size="32">Jd</args>
  </opcode>
  <opcode mnemonic="jbe">
    <return></return>
    <snippet>        if (cpu.cf() || cpu.zf())
    </snippet>
    <jcc/>
    <args size="8">Jb</args>
    <args size="16">Jw</args>
    <args size="32">Jd</args>
  </opcode>
  <opcode mnemonic="ja">
    <return></return>
    <snippet>        if (!cpu.cf() &amp;&amp; !cpu.zf())
    </snippet>
    <jcc/>
    <args size="8">Jb</args>
    <args size="16">Jw</args>
    <args size="32">Jd</args>
  </opcode>
  <opcode mnemonic="jae">
    <return></return>
    <snippet>        if (!cpu.cf())
    </snippet>
    <jcc/>
    <args size="8">Jb</args>
    <args size="16">Jw</args>
    <args size="32">Jd</args>
  </opcode>
  <opcode mnemonic="jg">
    <return></return>
    <snippet>        if (!cpu.zf() &amp;&amp; (cpu.sf() == cpu.of()))
    </snippet>
    <jcc/>
    <args size="8">Jb</args>
    <args size="16">Jw</args>
    <args size="32">Jd</args>
  </opcode>
  <opcode mnemonic="jge">
    <return></return>
    <snippet>        if (cpu.sf() == cpu.of())
    </snippet>
    <jcc/>
    <args size="8">Jb</args>
    <args size="16">Jw</args>
    <args size="32">Jd</args>
  </opcode>
  <opcode mnemonic="jo">
    <return></return>
    <snippet>        if (cpu.of())
    </snippet>
    <jcc/>
    <args size="8">Jb</args>
    <args size="16">Jw</args>
    <args size="32">Jd</args>
  </opcode>
  <opcode mnemonic="jno">
    <return></return>
    <snippet>        if (!cpu.of())
    </snippet>
    <jcc/>
    <args size="8">Jb</args>
    <args size="16">Jw</args>
    <args size="32">Jd</args>
  </opcode>
  <opcode mnemonic="jp">
    <return></return>
    <snippet>        if (cpu.pf())
    </snippet>
    <jcc/>
    <args size="8">Jb</args>
    <args size="16">Jw</args>
    <args size="32">Jd</args>
  </opcode>
  <opcode mnemonic="jnp">
    <return></return>
    <snippet>        if (!cpu.pf())
    </snippet>
    <jcc/>
    <args size="8">Jb</args>
    <args size="16">Jw</args>
    <args size="32">Jd</args>
  </opcode>
  <opcode mnemonic="js">
    <return></return>
    <snippet>        if (cpu.sf())
    </snippet>
    <jcc/>
    <args size="8">Jb</args>
    <args size="16">Jw</args>
    <args size="32">Jd</args>
  </opcode>
  <opcode mnemonic="jns">
    <return></return>
    <snippet>        if (!cpu.sf())
    </snippet>
    <jcc/>
    <args size="8">Jb</args>
    <args size="16">Jw</args>
    <args size="32">Jd</args>
  </opcode>

  <opcode mnemonic="jcxz">
    <return></return>
    <snippet>        if (cpu.r_cx.get16() == 0)
    </snippet>
    <jcc/>
    <args size="8">Jb</args>
    <args size="16">Jw</args>
    <args size="32">Jd</args>
  </opcode>

  <opcode mnemonic="jecxz">
    <return></return>
    <snippet>        if (cpu.r_ecx.get32() == 0)
    </snippet>
    <jcc/>
    <args size="8">Jb</args>
    <args size="16">Jw</args>
    <args size="32">Jd</args>
  </opcode>

  <opcode mnemonic="jmp_o16">
    <return>Branch.Jmp_Unknown</return>
    <snippet>        cpu.eip += blockLength;
        cpu.jumpFar_pm(cs, 0xffff &amp; targetEip);</snippet>
    <args size="16">Ap</args>
  </opcode>
  <opcode mnemonic="jmp_o32">
    <return>Branch.Jmp_Unknown</return>
    <snippet>        cpu.eip += blockLength;
        cpu.jumpFar_pm(cs, targetEip);</snippet>
    <args size="32">Ap</args>
  </opcode>
  <opcode mnemonic="jmp_o16">
    <return>Branch.Jmp_Unknown</return>
    <snippet>        cpu.eip += blockLength;
cpu.jumpFar_pm(cs, 0xffff &amp; targetEip);</snippet>
    <args size="16">Ep</args>
  </opcode>
  <opcode mnemonic="jmp_o32">
    <return>Branch.Jmp_Unknown</return>
    <snippet>        cpu.eip += blockLength;
        cpu.jumpFar_pm(cs, targetEip);</snippet>
    <args size="32">Ep</args>
  </opcode>
  <opcode mnemonic="jmp">
    <return>Branch.Jmp_Unknown</return>
    <snippet>        cpu.eip = $mask$op1.get;</snippet>
    <args size="16">Ew</args>
    <args size="32">Ed</args>
  </opcode>
  <opcode mnemonic="jmp">
    <return>Branch.T1</return>
    <snippet>        int tmpEip = cpu.eip + blockLength + jmp;
        cpu.cs.checkAddress(tmpEip);
        cpu.eip = tmpEip;</snippet>
    <args size="16">Jw</args>
    <args size="32">Jd</args>
  </opcode>
  <opcode mnemonic="jmp">
    <return>Branch.T1</return>
    <snippet>        int tmpEip = cpu.eip + blockLength + jmp;
        cpu.cs.checkAddress(tmpEip);
        cpu.eip = tmpEip;</snippet>
    <args size="8">Jb</args>
  </opcode>

  <opcode mnemonic="lahf">
      <return>Branch.None</return>
      <snippet>        int result = 0x02;
        if (cpu.sf()) result |= 0x80;
        if (cpu.zf()) result |= 0x40;
        if (cpu.af()) result |= 0x10;
        if (cpu.pf()) result |= 0x04;
        if (cpu.cf()) result |= 0x01;
        cpu.r_ah.set8((byte) result);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="lar">
      <return>Branch.None</return>
      <snippet>        $op1.setStaticOpcodes.lar(cpu, $op2.get, $op1.get));</snippet>
    <args size="16">Gw;Ew</args>
    <args size="32">Gd;Ew</args>
  </opcode>

  <opcode mnemonic="lsl">
      <return>Branch.None</return>
      <snippet>        $op1.setStaticOpcodes.lsl(cpu, $op2.get, $op1.get));</snippet>
    <args size="16">Gw;Ew</args>
    <args size="32">Gd;Ew</args>
  </opcode>

  <opcode mnemonic="lea">
    <return>Branch.None</return>
    <snippet>        $op1.set$op2.get);</snippet>
    <args size="16">Gw;M</args>
    <args size="32">Gd;M</args>
  </opcode>

  <opcode mnemonic="leave_o16">
    <return>Branch.None</return>
    <snippet>        if (cpu.ss.getDefaultSizeFlag())
        {
            cpu.r_esp.set32(cpu.r_ebp.get32());
            cpu.r_bp.set16(cpu.pop16());
        } else
        {
            cpu.r_sp.set16(cpu.r_bp.get16());
            cpu.r_bp.set16(cpu.pop16());
        }</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="leave_o32">
    <return>Branch.None</return>
    <snippet>        if (cpu.ss.getDefaultSizeFlag())
        {
            cpu.r_esp.set32(cpu.r_ebp.get32());
            cpu.r_ebp.set32(cpu.pop32());
        } else
        {
            cpu.r_sp.set16(cpu.r_bp.get16());
            cpu.r_ebp.set32(cpu.pop32());
        }</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="lmsw">
    <return>Branch.Jmp_Unknown</return>
    <snippet>                if (cpu.getCPL() != 0) throw new ProcessorException(ProcessorException.Type.GENERAL_PROTECTION, 0, true);//ProcessorException.GENERAL_PROTECTION_0;
        cpu.setCR0((cpu.getCR0() &amp; ~0xe) | ($op1.get &amp; 0xe));
        cpu.eip += blockLength;</snippet>
    <args size="16">Ew</args>
  </opcode>

  <opcode mnemonic="loop_a16">
      <return></return>
      <snippet>        cpu.r_cx.set16(cpu.r_cx.get16()-1);
        if (cpu.r_cx.get16() != 0)
</snippet>
<jcc/>
    <args size="8">Jb</args>
  </opcode>

  <opcode mnemonic="loop_a32">
      <return></return>
      <snippet>        cpu.r_ecx.set32(cpu.r_ecx.get32()-1);
        if (cpu.r_ecx.get32() != 0)
</snippet>
<jcc/>
    <args size="8">Jb</args>
  </opcode>

  <opcode mnemonic="loope_a16">
      <return></return>
      <snippet>        cpu.r_cx.set16(cpu.r_cx.get16()-1);
        if ((cpu.r_cx.get16() != 0) &amp;&amp; cpu.zf())</snippet>
<jcc/>
    <args size="8">Jb</args>
  </opcode>
  <opcode mnemonic="loope_a32">
      <return></return>
      <snippet>        cpu.r_ecx.set32(cpu.r_ecx.get32()-1);
        if ((cpu.r_cx.get32() != 0) &amp;&amp; cpu.zf())</snippet>
<jcc/>
    <args size="8">Jb</args>
  </opcode>

  <opcode mnemonic="loopne_a16">
      <return></return>
      <snippet>        cpu.r_cx.set16(cpu.r_cx.get16()-1);
        if ((cpu.r_cx.get16() != 0) &amp;&amp; !cpu.zf())</snippet>
<jcc/>
    <args size="8">Jb</args>
  </opcode>

  <opcode mnemonic="loopne_a32">
      <return></return>
      <snippet>        cpu.r_ecx.set32(cpu.r_ecx.get32()-1);
        if ((cpu.r_ecx.get32() != 0) &amp;&amp; !cpu.zf())</snippet>
<jcc/>
    <args size="8">Jb</args>
  </opcode>

  <opcode mnemonic="lds_o16">
      <return>Branch.None</return>
      <snippet>        int addr = $op2.get + op2.getBase(cpu);
        cpu.ds(0xFFFF &amp; cpu.linearMemory.getWord(addr+2));
        $op1.setcpu.linearMemory.getWord(addr));</snippet>
    <args size="16">Gw;M</args>
    <args size="32">Gd;M</args>
  </opcode>

  <opcode mnemonic="lds_o32">
      <return>Branch.None</return>
      <snippet>        int addr = $op2.get + op2.getBase(cpu);
        cpu.ds(0xFFFF &amp; cpu.linearMemory.getWord(addr+4));
        $op1.setcpu.linearMemory.getDoubleWord(addr));</snippet>
    <args size="16">Gw;M</args>
    <args size="32">Gd;M</args>
  </opcode>

  <opcode mnemonic="les_o16">
      <return>Branch.None</return>
      <snippet>        int addr = $op2.get + op2.getBase(cpu);
        cpu.es(0xFFFF &amp; cpu.linearMemory.getWord(addr+2));
        $op1.setcpu.linearMemory.getWord(addr));</snippet>
    <args size="16">Gw;M</args>
    <args size="32">Gd;M</args>
  </opcode>

  <opcode mnemonic="les_o32">
      <return>Branch.None</return>
      <snippet>        int addr = $op2.get + op2.getBase(cpu);
        cpu.es(0xFFFF &amp; cpu.linearMemory.getWord(addr+4));
        $op1.setcpu.linearMemory.getDoubleWord(addr));</snippet>
    <args size="16">Gw;M</args>
    <args size="32">Gd;M</args>
  </opcode>

  <opcode mnemonic="lfs_o32">
      <return>Branch.None</return>
      <snippet>        int addr = $op2.get + op2.getBase(cpu);
        cpu.fs(0xFFFF &amp; cpu.linearMemory.getWord(addr+4));
        $op1.setcpu.linearMemory.getDoubleWord(addr));</snippet>
    <args size="16">Gw;M</args>
    <args size="32">Gd;M</args>
  </opcode>

  <opcode mnemonic="lss_o16">
      <return>Branch.None</return>
      <snippet>        int addr = $op2.get + op2.getBase(cpu);
        cpu.ss(0xFFFF &amp; cpu.linearMemory.getWord(addr+2));
        $op1.setcpu.linearMemory.getWord(addr));</snippet>
    <args size="16">Gw;M</args>
    <args size="32">Gd;M</args>
  </opcode>

  <opcode mnemonic="lss_o32">
      <return>Branch.None</return>
      <snippet>        int addr = $op2.get + op2.getBase(cpu);
        cpu.ss(0xFFFF &amp; cpu.linearMemory.getWord(addr+4));
        $op1.setcpu.linearMemory.getDoubleWord(addr));</snippet>
    <args size="32">Gd;M</args>
  </opcode>

  <opcode mnemonic="lgdt_o16">
      <return>Branch.None</return>
      <snippet>        int addr = $op1.get + op1.getBase(cpu);
        int limit = 0xffff &amp; cpu.linearMemory.getWord(addr);
        int base = 0x00ffffff &amp; cpu.linearMemory.getDoubleWord(addr+2);
        cpu.gdtr = cpu.createDescriptorTableSegment(base, limit);</snippet>
    <args size="0">M</args>
  </opcode>

  <opcode mnemonic="lgdt_o32">
      <return>Branch.None</return>
      <snippet>        int addr = $op1.get + op1.getBase(cpu);
        int limit = 0xffff &amp; cpu.linearMemory.getWord(addr);
        int base = cpu.linearMemory.getDoubleWord(addr+2);
        cpu.gdtr = cpu.createDescriptorTableSegment(base, limit);</snippet>
    <args size="0">M</args>
  </opcode>

  <opcode mnemonic="lidt_o16">
      <return>Branch.None</return>
      <snippet>        int addr = $op1.get + op1.getBase(cpu);
        int limit = 0xffff &amp; cpu.linearMemory.getWord(addr);
        int base = 0x00ffffff &amp; cpu.linearMemory.getDoubleWord(addr+2);
        cpu.idtr = cpu.createDescriptorTableSegment(base, limit);</snippet>
    <args size="0">M</args>
  </opcode>

  <opcode mnemonic="lidt_o32">
      <return>Branch.None</return>
      <snippet>        int addr = $op1.get + op1.getBase(cpu);
        int limit = 0xffff &amp; cpu.linearMemory.getWord(addr);
        int base = cpu.linearMemory.getDoubleWord(addr+2);
        cpu.idtr = cpu.createDescriptorTableSegment(base, limit);</snippet>
    <args size="0">M</args>
  </opcode>

  <opcode mnemonic="lldt">
      <return>Branch.None</return>
      <snippet>        int selector = $op1.get &amp; 0xffff;

	if (selector == 0)
        {
	    cpu.ldtr = SegmentFactory.NULL_SEGMENT;
        }
        else
        {
	Segment newSegment = cpu.getSegment(selector &amp; ~0x4);
	if (newSegment.getType() != 0x02)
	    throw new ProcessorException(ProcessorException.Type.GENERAL_PROTECTION, selector, true);

	if (!(newSegment.isPresent()))
	    throw new ProcessorException(ProcessorException.Type.GENERAL_PROTECTION, selector, true);
        cpu.ldtr = newSegment;
        }</snippet>
    <args size="16">Ew</args>
  </opcode>

  <opcode mnemonic="lodsb_a16" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.lodsb_a16(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="lodsb_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.lodsb_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="lodsw_a16" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.lodsw_a16(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="lodsw_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.lodsw_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="lodsd_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.lodsd_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="ltr">
      <return>Branch.None</return>
      <snippet>        int selector = $op1.get;
        if ((selector &amp; 0x4) != 0) //must be gdtr table
	    throw new ProcessorException(ProcessorException.Type.GENERAL_PROTECTION, selector, true);

	Segment tempSegment = cpu.getSegment(selector);

	if ((tempSegment.getType() != 0x01) &amp;&amp; (tempSegment.getType() != 0x09))
	    throw new ProcessorException(ProcessorException.Type.GENERAL_PROTECTION, selector, true);

	if (!(tempSegment.isPresent()))
	    throw new ProcessorException(ProcessorException.Type.GENERAL_PROTECTION, selector, true);

	long descriptor = cpu.readSupervisorQuadWord(cpu.gdtr, (selector &amp; 0xfff8)) | (0x1L &lt;&lt; 41); // set busy flag in segment descriptor
	cpu.setSupervisorQuadWord(cpu.gdtr, selector &amp; 0xfff8, descriptor);
	
	//reload segment
	cpu.tss = cpu.getSegment(selector);</snippet>
    <args size="16">Ew</args>
  </opcode>

  <opcode mnemonic="mov">
    <return>Branch.None</return>
    <snippet>        $op1.set$cast$op2.get);</snippet>
    <args size="8">Ob;AL</args>
    <args size="8">AL;Ob</args>
    <args size="8">Eb;Gb</args>
    <args size="8">Eb;Ib</args>
    <args size="8">Gb;Eb</args>
    <args size="8">ALr8b;Ib</args>
    <args size="8">CLr9b;Ib</args>
    <args size="8">DLr10b;Ib</args>
    <args size="8">BLr11b;Ib</args>
    <args size="8">AHr12b;Ib</args>
    <args size="8">CHr13b;Ib</args>
    <args size="8">DHr14b;Ib</args>
    <args size="8">BHr15b;Ib</args>
    <args size="16">Ew;S</args>
    <args size="32">Ed;S</args>
    <args size="16">Ew;Gw</args>
    <args size="32">Ed;Gd</args>
    <args size="16">Ew;Iw</args>
    <args size="32">Ed;Id</args>
    <args size="16">Gw;Ew</args>
    <args size="32">Gd;Ed</args>
    <args size="16">rAXr8;Iw</args>
    <args size="16">rCXr9;Iw</args>
    <args size="16">rDXr10;Iw</args>
    <args size="16">rBXr11;Iw</args>
    <args size="16">rSPr12;Iw</args>
    <args size="16">rBPr13;Iw</args>
    <args size="16">rSIr14;Iw</args>
    <args size="16">rDIr15;Iw</args>
    <args size="32">rAXr8;Id</args>
    <args size="32">rCXr9;Id</args>
    <args size="32">rDXr10;Id</args>
    <args size="32">rBXr11;Id</args>
    <args size="32">rSPr12;Id</args>
    <args size="32">rBPr13;Id</args>
    <args size="32">rSIr14;Id</args>
    <args size="32">rDIr15;Id</args>
    <args size="32">R;C</args>
    <args size="32">R;D</args>
    <args size="32">D;R</args>
  </opcode>

  <opcode mnemonic="mov">
    <return>Branch.None</return>
    <snippet>        $op1.set$cast$op2.get);
        if (segIndex == Processor.getSegmentIndex("ss"))
            cpu.eflagsInterruptEnable = false;</snippet>
    <args size="16">S;Ew</args>
    <args size="16">S;Ed</args>
  </opcode>

  <opcode mnemonic="mov">
    <return>Branch.T1</return>
    <snippet>        cpu.eip += blockLength;
        $op1.set$cast$op2.get);</snippet>
    <args size="32">C;R</args>
  </opcode>

  <opcode mnemonic="mov_o16">
    <return>Branch.None</return>
    <snippet>        $op1.set$cast$op2.get);</snippet>
    <args size="16">Ow;rAX</args>
    <args size="16">rAX;Ow</args>
  </opcode>

  <opcode mnemonic="mov_o32">
    <return>Branch.None</return>
    <snippet>        $op1.set$cast$op2.get);</snippet>
    <args size="32">Od;rAX</args>
    <args size="32">rAX;Od</args>
  </opcode>

  <opcode mnemonic="movsx">
    <return>Branch.None</return>
    <snippet>        $op1.set$cast$op2.get);</snippet>
    <args size="16">Gw;Eb</args>
    <args size="32">Gd;Eb</args>
    <args size="32">Gd;Ew</args>
  </opcode>

  <opcode mnemonic="movzx">
    <return>Branch.None</return>
    <snippet>        $op1.set$mask2$op2.get);</snippet>
    <args size="16">Gw;Eb</args>
    <args size="32">Gd;Eb</args>
    <args size="32">Gd;Ew</args>
  </opcode>

  <opcode mnemonic="mul">
    <return>Branch.None</return>
    <snippet>            cpu.af = false;
        int res16 = ($op1.get &amp; 0xff) * (0xFF &amp; cpu.r_eax.get8());
        cpu.r_eax.set16(res16);
        cpu.cf = cpu.of = (cpu.r_eax.getHigh() != 0);
        cpu.flagResult = (short)res16;
        cpu.flagStatus = SZP;</snippet>
    <args size="8">Eb</args>
  </opcode>
  <opcode mnemonic="mul">
    <return>Branch.None</return>
    <snippet>            cpu.af = false;
            long res64 = ($mask$op1.get) * ($mask cpu.r_eax.get$size());
            cpu.r_eax.set$size($castres64);
            cpu.r_edx.set$size($cast(res64 >> $size));
            cpu.cf = cpu.of = (cpu.r_edx.get$size() != 0);
            cpu.flagResult = (int)res64;
            cpu.flagStatus = SZP;</snippet>
    <args size="16">Ew</args>
  </opcode>
  <opcode mnemonic="mul">
    <return>Branch.None</return>
    <snippet>            cpu.af = false;
            long res64 = (0xffffffffL &amp; $op1.get) * (0xffffffffL &amp; cpu.r_eax.get$size());
            cpu.r_eax.set$size($castres64);
            cpu.r_edx.set$size($cast(res64 >> $size));
            cpu.cf = cpu.of = (cpu.r_edx.get$size() != 0);
            cpu.flagResult = (int)res64;
            cpu.flagStatus = SZP;</snippet>
    <args size="32">Ed</args>
  </opcode>

  <opcode mnemonic="neg">
    <return>Branch.None</return>
    <snippet>            cpu.flagOp1 = $op1.get;
            cpu.flagResult = $cast(-cpu.flagOp1);
            $op1.set$castcpu.flagResult);
            cpu.flagIns = UCodes.NEG$size;
            cpu.flagStatus = OSZAPC;</snippet>
    <args size="8">Eb</args>
    <args size="16">Ew</args>
    <args size="32">Ed</args>
  </opcode>

  <opcode mnemonic="nop">
    <return>Branch.None</return>
    <snippet></snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="not">
    <return>Branch.None</return>
    <snippet>        $op1.set$cast~$op1.get);</snippet>
    <args size="8">Eb</args>
    <args size="16">Ew</args>
    <args size="32">Ed</args>
  </opcode>

  <opcode mnemonic="or">
    <return>Branch.None</return>
    <snippet>        cpu.of = cpu.af = cpu.cf = false;
        cpu.flagResult = $cast($op1.get | $op2.get);
        $op1.set$castcpu.flagResult);
        cpu.flagStatus = SZP;</snippet>
    <args size="8">AL;Ib</args>
    <args size="8">Eb;Gb</args>
    <args size="8">Eb;Ib</args>
    <args size="8">Gb;Eb</args>
    <args size="16">Ew;Gw</args>
    <args size="32">Ed;Gd</args>
    <args size="16">Gw;Ew</args>
    <args size="32">Gd;Ed</args>
    <args size="16">Ew;Iw</args>
    <args size="16">Ew;Ib</args>
    <args size="32">Ed;Ib</args>
    <args size="32">Ed;Id</args>
  </opcode>

  <opcode mnemonic="or_o16">
    <return>Branch.None</return>
    <snippet>        cpu.of = cpu.af = cpu.cf = false;
        cpu.flagResult = $cast($op1.get | $op2.get);
        $op1.set$castcpu.flagResult);
        cpu.flagStatus = SZP;</snippet>
    <args size="16">rAX;Iw</args>
  </opcode>

  <opcode mnemonic="or_o32">
    <return>Branch.None</return>
    <snippet>        cpu.of = cpu.af = cpu.cf = false;
        cpu.flagResult = $cast($op1.get | $op2.get);
        $op1.set$castcpu.flagResult);
        cpu.flagStatus = SZP;</snippet>
    <args size="32">rAX;Id</args>
  </opcode>

  <opcode mnemonic="out">
    <return>Branch.None</return>
    <snippet>        if (cpu.checkIOPermissions8($mask2$op2.get))
            cpu.ioports.ioPortWrite8($mask1$op1.get, $mask2$op2.get);
        else
            throw ProcessorException.GENERAL_PROTECTION_0;</snippet>
    <args size="8">Ib;AL</args>
    <args size="8">DX;AL</args>
  </opcode>
  <opcode mnemonic="out_o16">
    <return>Branch.None</return>
    <snippet>        if (cpu.checkIOPermissions16($mask2$op2.get))
            cpu.ioports.ioPortWrite16($mask1$op1.get, $mask2$op2.get);
        else
            throw ProcessorException.GENERAL_PROTECTION_0;</snippet>
    <args size="16">DX;eAX</args>
  </opcode>
  <opcode mnemonic="out_o32">
    <return>Branch.None</return>
    <snippet>        if (cpu.checkIOPermissions32($mask2$op2.get))
            cpu.ioports.ioPortWrite32($mask1$op1.get, $op2.get);
        else
            throw ProcessorException.GENERAL_PROTECTION_0;</snippet>
    <args size="32">DX;eAX</args>
  </opcode>

  <opcode mnemonic="rep_outsw_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        if (cpu.checkIOPermissions16(cpu.r_dx.get16() &amp; 0xffff))
            StaticOpcodes.rep_outsw_a32(cpu, seg);
        else
            throw ProcessorException.GENERAL_PROTECTION_0;</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="pause">
    <return>Branch.None</return>
    <snippet>        // hint that this is a spinloop</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="pop">
    <return>Branch.None</return>
    <snippet>        $op1.set$castcpu.pop$size());</snippet>
    <args size="16">Ew</args>
    <args size="32">Ed</args>
  </opcode>

  <opcode mnemonic="pop_o16">
    <return>Branch.None</return>
    <snippet>        $op1.set$castcpu.pop$size());</snippet>
    <args size="16">Ew</args>
    <args size="16">DS</args>
    <args size="16">ES</args>
    <args size="16">FS</args>
    <args size="16">GS</args>
  </opcode>

  <opcode mnemonic="pop_o16">
    <return>Branch.None</return>
    <snippet>        $op1.set$castcpu.pop$size());
        cpu.eflagsInterruptEnable = false;</snippet>
    <args size="16">SS</args>
  </opcode>

  <opcode mnemonic="pop_o32">
    <return>Branch.None</return>
    <snippet>        $op1.set$castcpu.pop$size());
        cpu.eflagsInterruptEnable = false;</snippet>
    <args size="32">SS</args>
  </opcode>

  <opcode mnemonic="pop_o16">
    <return>Branch.None</return>
    <snippet>        $op1.setcpu.pop$size());</snippet>
    <args size="16">rAXr8</args>
    <args size="16">rBXr11</args>
    <args size="16">rCXr9</args>
    <args size="16">rDXr10</args>
    <args size="16">rSPr12</args>
    <args size="16">rBPr13</args>
    <args size="16">rSIr14</args>
    <args size="16">rDIr15</args>
  </opcode>

  <opcode mnemonic="pop_o32">
    <return>Branch.None</return>
    <snippet>        $op1.setcpu.pop$size());</snippet>
    <args size="32">DS</args>
    <args size="32">ES</args>
    <args size="32">FS</args>
    <args size="32">GS</args>
    <args size="32">rAXr8</args>
    <args size="32">rCXr9</args>
    <args size="32">rDXr10</args>
    <args size="32">rBXr11</args>
    <args size="32">rSPr12</args>
    <args size="32">rBPr13</args>
    <args size="32">rSIr14</args>
    <args size="32">rDIr15</args>
  </opcode>

  <opcode mnemonic="popa">
    <return>Branch.None</return>
    <snippet>        cpu.popa();</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="popad">
    <return>Branch.None</return>
    <snippet>        cpu.popad();</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="popfw">
    <return>Branch.None</return>
    <snippet>        cpu.setFlags($castcpu.pop16());</snippet>
    <args size="16"></args>
  </opcode>

  <opcode mnemonic="popfd">
    <return>Branch.None</return>
    <snippet>        if (cpu.getCPL() == 0)
			cpu.setEFlags(((cpu.getEFlags() &amp; 0x20000) | (cpu.pop32() &amp; ~(0x20000 | 0x180000))));
		    else {
			if (cpu.getCPL() > cpu.eflagsIOPrivilegeLevel)
			    cpu.setEFlags(((cpu.getEFlags() &amp; 0x23200) | (cpu.pop32() &amp; ~(0x23200 | 0x180000))));
			else
			    cpu.setEFlags(((cpu.getEFlags() &amp; 0x23000) | (cpu.pop32() &amp; ~(0x23000 | 0x180000))));
		    }</snippet>
    <args size="32"></args>
  </opcode>

  <opcode mnemonic="push">
    <return>Branch.None</return>
    <snippet>        cpu.push$size($cast$op1.get);</snippet>
    <args size="16">Iw</args>
    <args size="16">Ew</args>
    <args size="32">Ed</args>
  </opcode>

  <opcode mnemonic="push_o16">
    <return>Branch.None</return>
    <snippet>        cpu.push$size($cast$op1.get);</snippet>
    <args size="16">Ib</args>
    <args size="16">rAXr8</args>
    <args size="16">rCXr9</args>
    <args size="16">rDXr10</args>
    <args size="16">rBXr11</args>
    <args size="16">rSPr12</args>
    <args size="16">rBPr13</args>
    <args size="16">rSIr14</args>
    <args size="16">rDIr15</args>
    <args size="16">CS</args>
    <args size="16">DS</args>
    <args size="16">ES</args>
    <args size="16">FS</args>
    <args size="16">GS</args>
    <args size="16">SS</args>
  </opcode>

  <opcode mnemonic="push_o32">
    <return>Branch.None</return>
    <snippet>        cpu.push$size($cast$op1.get);</snippet>
    <args size="32">Ib</args>
    <args size="32">rAXr8</args>
    <args size="32">rCXr9</args>
    <args size="32">rDXr10</args>
    <args size="32">rBXr11</args>
    <args size="32">rSPr12</args>
    <args size="32">rBPr13</args>
    <args size="32">rSIr14</args>
    <args size="32">rDIr15</args>
    <args size="32">Id</args>
  </opcode>

  <opcode mnemonic="push_o32">
    <return>Branch.None</return>
    <snippet>        cpu.push32($mask$op1.get);</snippet>
    <args size="16">CS</args>
    <args size="16">DS</args>
    <args size="16">ES</args>
    <args size="16">FS</args>
    <args size="16">GS</args>
    <args size="16">SS</args>
  </opcode>

  <opcode mnemonic="pusha">
    <return>Branch.None</return>
    <snippet>        cpu.pusha();</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="pushad">
    <return>Branch.None</return>
    <snippet>        cpu.pushad();</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="pushfw">
    <return>Branch.None</return>
    <snippet>        cpu.push16((short)cpu.getEFlags());</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="pushfd">
    <return>Branch.None</return>
    <snippet>        cpu.push32(~0x30000 &amp; cpu.getEFlags());</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rdtsc">
    <return>Branch.None</return>
    <snippet>        if ((cpu.getCPL() == 0) || ((cpu.getCR4() &amp; 0x4) == 0)) {
	    long tsc = cpu.getClockCount();
            cpu.r_eax.set32((int)tsc);
            cpu.r_edx.set32((int)(tsc >> 32));
	} else
	    throw ProcessorException.GENERAL_PROTECTION_0;</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="cmpsb_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.cmpsb_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_cmpsb_a16" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_cmpsb_a16(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_cmpsb_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_cmpsb_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_cmpsd_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_cmpsd_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_insw_a32">
    <return>Branch.None</return>
    <snippet>        if (cpu.checkIOPermissions16(cpu.r_dx.get16() &amp; 0xffff))
            StaticOpcodes.rep_insw_a32(cpu);
        else
            throw ProcessorException.GENERAL_PROTECTION_0;</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="movsb_a16" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.movsb_a16(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="movsb_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.movsb_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="movsw_a16" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.movsw_a16(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="movsw_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.movsw_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="movsd_a16" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.movsd_a16(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="movsd_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.movsd_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_movsb_a16" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_movsb_a16(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_movsb_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_movsb_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="repne_movsb_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_movsb_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_movsw_a16" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_movsw_a16(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_movsw_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_movsw_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_movsd_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_movsd_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="repne_movsd_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_movsd_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_movsd_a16" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_movsd_a16(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="stosb_a16">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.stosb_a16(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="stosb_a32">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.stosb_a32(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="stosw_a32">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.stosw_a32(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="stosd_a16">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.stosd_a16(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_stosb_a16">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_stosb_a16(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_stosb_a32">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_stosb_a32(cpu);</snippet>
    <args size="0"></args>
  </opcode>
  <opcode mnemonic="repne_stosb_a32">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_stosb_a32(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="stosw_a16">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.stosw_a16(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_stosw_a16">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_stosw_a16(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_stosw_a32">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_stosw_a32(cpu);</snippet>
    <args size="0"></args>
  </opcode>
  <opcode mnemonic="repne_stosw_a32">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_stosw_a32(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="stosd_a32">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.stosd_a32(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_stosd_a16">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_stosd_a16(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_stosd_a32">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_stosd_a32(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="scasb_a16">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.scasb_a16(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="scasb_a32">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.scasb_a32(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_scasb_a32">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_scasb_a32(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="repne_scasb_a16">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.repne_scasb_a16(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="repne_scasb_a32">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.repne_scasb_a32(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_scasd_a32">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_scasd_a32(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="repne_scasd_a32">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.repne_scasd_a32(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="ret_o16">
    <return>Branch.Ret</return>
    <snippet>        cpu.eip = 0xFFFF &amp; cpu.pop16();</snippet>
    <args size="16"></args>
  </opcode>

  <opcode mnemonic="ret_o16">
    <return>Branch.Ret</return>
    <snippet>        cpu.eip = 0xFFFF &amp; cpu.pop16();
        if (cpu.ss.getDefaultSizeFlag())
            cpu.r_esp.set32(cpu.r_esp.get32()+$op1.get);
        else
            cpu.r_sp.set16(cpu.r_sp.get16()+$op1.get);</snippet>
    <args size="16">Iw</args>
  </opcode>

  <opcode mnemonic="ret_o32">
    <return>Branch.Ret</return>
    <snippet>                cpu.eip = cpu.pop32();</snippet>
    <args size="32"></args>
  </opcode>

  <opcode mnemonic="ret_o32">
    <return>Branch.Ret</return>
    <snippet>                cpu.eip = cpu.pop32();
        if (cpu.ss.getDefaultSizeFlag())
            cpu.r_esp.set32(cpu.r_esp.get32()+$op1.get);
        else
            cpu.r_sp.set16(cpu.r_sp.get16()+$op1.get);</snippet>
    <args size="16">Iw</args>
  </opcode>

  <opcode mnemonic="retf_o16">
    <return>Branch.Ret</return>
    <snippet>        if (cpu.ss.getDefaultSizeFlag())
            cpu.ret_far_o16_a32(0);
        else
            cpu.ret_far_o16_a16(0);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="retf_o16">
    <return>Branch.Ret</return>
    <snippet>        if (cpu.ss.getDefaultSizeFlag())
            cpu.ret_far_o16_a32($op1.get);
        else
            cpu.ret_far_o16_a16($op1.get);</snippet>
    <args size="16">Iw</args>
  </opcode>

  <opcode mnemonic="retf_o32">
    <return>Branch.Ret</return>
    <snippet>        if (cpu.ss.getDefaultSizeFlag())
            cpu.ret_far_o32_a32(0);
        else
            cpu.ret_far_o32_a16(0);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="retf_o32">
    <return>Branch.Ret</return>
    <snippet>        if (cpu.ss.getDefaultSizeFlag())
            cpu.ret_far_o32_a32($op1.get);
        else
            cpu.ret_far_o32_a16($op1.get);</snippet>
    <args size="16">Iw</args>
  </opcode>

  <opcode mnemonic="rcl">
    <return>Branch.None</return>
    <snippet>            int shift = $op2.get &amp; 0x1f;
            shift %= $size+1;
            long val = $mask$op1.get;
            val |= cpu.cf() ? 1L &lt;&lt; $size : 0;
            val = (val &lt;&lt; shift) | (val &gt;&gt;&gt; ($size+1-shift));
            $op1.set$cast(int)val);
            boolean bit31 = (val &amp; (1L &lt;&lt; ($size-1))) != 0;
            boolean bit32 = (val &amp; (1L &lt;&lt; ($size))) != 0;
            cpu.cf(bit32);
            if (shift == 1)
                cpu.of(bit31 ^ bit32);</snippet>
    <args size="8">Eb;I1</args>    
    <args size="16">Ew;I1</args>
  </opcode>
  <opcode mnemonic="rcl">
    <return>Branch.None</return>
    <snippet>            int shift = $op2.get &amp; 0x1f;
            shift %= $size+1;
            long val = 0xffffffffL &amp; $op1.get;
            val |= cpu.cf() ? 1L &lt;&lt; $size : 0;
            val = (val &lt;&lt; shift) | (val &gt;&gt;&gt; ($size+1-shift));
            $op1.set$cast(int)val);
            boolean bit31 = (val &amp; (1L &lt;&lt; ($size-1))) != 0;
            boolean bit32 = (val &amp; (1L &lt;&lt; ($size))) != 0;
            cpu.cf(bit32);
            if (shift == 1)
                cpu.of(bit31 ^ bit32);</snippet>
    <args size="8">Eb;I1</args>
    <args size="8">Eb;CL</args>
    <args size="16">Ew;I1</args>
    <args size="16">Ew;CL</args>
    <args size="32">Ed;I1</args>
    <args size="32">Ed;CL</args>
  </opcode>

  <opcode mnemonic="rcr">
    <return>Branch.None</return>
    <snippet>            int shift = $op2.get &amp; 0x1f;
            shift %= $size+1;
            if (shift != 0)
            {
            long val = $mask$op1.get;
            val |= cpu.cf() ? 1L &lt;&lt; $size : 0;
            val = (val &gt;&gt;&gt; shift) | (val &lt;&lt; ($size+1-shift));
            $op1.set$cast(int)val);
            boolean bit30  = (val &amp;  (1L &lt;&lt; ($size-2))) != 0;
            boolean bit31 = (val &amp; (1L &lt;&lt; ($size-1))) != 0;
            cpu.cf((val &amp; (1L &lt;&lt; $size)) != 0);
            if (shift == 1)
                cpu.of(bit30 ^ bit31);
            }</snippet>
    <args size="8">Eb;I1</args>
    <args size="8">Eb;CL</args>
    <args size="16">Ew;I1</args>
    <args size="16">Ew;CL</args>
  </opcode>
  <opcode mnemonic="rcr">
    <return>Branch.None</return>
    <snippet>            int shift = $op2.get &amp; 0x1f;
            if (shift != 0)
            {
            shift %= $size+1;
            long val = 0xffffffffL &amp; $op1.get;
            val |= cpu.cf() ? 1L &lt;&lt; $size : 0;
            val = (val &gt;&gt;&gt; shift) | (val &lt;&lt; ($size+1-shift));
            $op1.set$cast(int)val);
            boolean bit30  = (val &amp;  (1L &lt;&lt; ($size-2))) != 0;
            boolean bit31 = (val &amp; (1L &lt;&lt; ($size-1))) != 0;
            cpu.cf((val &amp; (1L &lt;&lt; $size)) != 0);
            if (shift == 1)
                cpu.of(bit30 ^ bit31);
            }</snippet>
    <args size="32">Ed;I1</args>
    <args size="32">Ed;CL</args>
  </opcode>

  <opcode mnemonic="rol">
    <return>Branch.None</return>
    <snippet>            int shift = $op2.get &amp; ($size-1);
            int reg0 = $mask$op1.get;
            int res = (reg0 &lt;&lt; shift) | (reg0 >>> ($size - shift));
            $op1.set$castres);
            boolean bit0  = (res &amp; 1 ) != 0;
            boolean bit31 = (res &amp; (1 &lt;&lt; ($size-1))) != 0;
            if ($op2.get > 0)
            {
                cpu.cf = bit0;
                if ($op2.get == 1)
                {
                    cpu.of = bit0 ^ bit31;
                    cpu.flagStatus &amp;= NOFCF;
                }
                else
                    cpu.flagStatus &amp;= NCF;
            }</snippet>
    <args size="8">Eb;I1</args>
    <args size="8">Eb;Ib</args>
    <args size="8">Eb;CL</args>
    <args size="16">Ew;I1</args>
    <args size="32">Ed;I1</args>
    <args size="16">Ew;Ib</args>
    <args size="32">Ed;Ib</args>
    <args size="16">Ew;CL</args>
    <args size="32">Ed;CL</args>
  </opcode>

  <opcode mnemonic="ror">
    <return>Branch.None</return>
    <snippet>            int shift = $op2.get &amp; ($size-1);
            int reg0 = $mask1$op1.get;
            int res = (reg0 >>> shift) | (reg0 &lt;&lt; ($size - shift));
            $op1.set$castres);
            boolean bit30  = (res &amp; (1 &lt;&lt; ($size-2))) != 0;
            boolean bit31 = (res &amp; (1 &lt;&lt; ($size-1))) != 0;
            if ($op2.get > 0)
            {
                cpu.cf = bit31;
                if ($op2.get == 1)
                {
                    cpu.of = bit30 ^ bit31;
                    cpu.flagStatus &amp;= NOFCF;
                }
                else
                    cpu.flagStatus &amp;= NCF;
            }</snippet>
    <args size="8">Eb;I1</args>
    <args size="8">Eb;Ib</args>
    <args size="8">Eb;CL</args>
    <args size="16">Ew;I1</args>
    <args size="32">Ed;I1</args>
    <args size="16">Ew;Ib</args>
    <args size="32">Ed;Ib</args>
    <args size="16">Ew;CL</args>
    <args size="32">Ed;CL</args>
  </opcode>

  <opcode mnemonic="sahf">
    <return>Branch.None</return>
    <snippet>        byte fx  = (byte)(cpu.r_ah.get8());
        cpu.flagStatus &amp;= OF;
        cpu.sf = (fx &amp; (1&lt;&lt;7)) != 0;
        cpu.zf = (fx &amp; (1&lt;&lt;6)) != 0;
        cpu.af = (fx &amp; (1&lt;&lt;4)) != 0;
        cpu.pf = (fx &amp; (1&lt;&lt;2)) != 0;
        cpu.cf = (fx &amp; 1) != 0;;</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="seta">
    <return>Branch.None</return>
    <snippet>        $op1.set$cast(!cpu.cf() &amp;&amp; !cpu.zf() ? 1 : 0));</snippet>
    <args size="8">Eb</args>
  </opcode>
  <opcode mnemonic="setae">
    <return>Branch.None</return>
    <snippet>        $op1.set$cast(!cpu.cf() ? 1 : 0));</snippet>
    <args size="8">Eb</args>
  </opcode>
  <opcode mnemonic="setb">
    <return>Branch.None</return>
    <snippet>        $op1.set$cast(cpu.cf() ? 1 : 0));</snippet>
    <args size="8">Eb</args>
  </opcode>
  <opcode mnemonic="setbe">
    <return>Branch.None</return>
    <snippet>        $op1.set$cast(cpu.cf() || cpu.zf() ? 1 : 0));</snippet>
    <args size="8">Eb</args>
  </opcode>
  <opcode mnemonic="setne">
    <return>Branch.None</return>
    <snippet>        $op1.set$cast(!cpu.zf() ? 1 : 0));</snippet>
    <args size="8">Eb</args>
  </opcode>
  <opcode mnemonic="sete">
    <return>Branch.None</return>
    <snippet>        $op1.set$cast(cpu.zf() ? 1 : 0));</snippet>
    <args size="8">Eb</args>
  </opcode>
  <opcode mnemonic="setg">
    <return>Branch.None</return>
    <snippet>        $op1.set$cast((!cpu.zf() &amp;&amp; (cpu.sf() == cpu.of())) ? 1 : 0));</snippet>
    <args size="8">Eb</args>
  </opcode>
  <opcode mnemonic="setge">
    <return>Branch.None</return>
    <snippet>        $op1.set$cast((cpu.sf() == cpu.of()) ? 1 : 0));</snippet>
    <args size="8">Eb</args>
  </opcode>
  <opcode mnemonic="setl">
    <return>Branch.None</return>
    <snippet>        $op1.set$cast((cpu.sf() != cpu.of()) ? 1 : 0));</snippet>
    <args size="8">Eb</args>
  </opcode>
  <opcode mnemonic="setle">
    <return>Branch.None</return>
    <snippet>        $op1.set$cast((cpu.zf() || (cpu.sf() != cpu.of())) ? 1 : 0));</snippet>
    <args size="8">Eb</args>
  </opcode>
  <opcode mnemonic="seto">
    <return>Branch.None</return>
    <snippet>        $op1.set$cast(cpu.of() ? 1 : 0));</snippet>
    <args size="8">Eb</args>
  </opcode>
  <opcode mnemonic="setno">
    <return>Branch.None</return>
    <snippet>        $op1.set$cast(!cpu.of() ? 1 : 0));</snippet>
    <args size="8">Eb</args>
  </opcode>
  <opcode mnemonic="setp">
    <return>Branch.None</return>
    <snippet>        $op1.set$cast(cpu.pf() ? 1 : 0));</snippet>
    <args size="8">Eb</args>
  </opcode>
  <opcode mnemonic="setnp">
    <return>Branch.None</return>
    <snippet>        $op1.set$cast(!cpu.pf() ? 1 : 0));</snippet>
    <args size="8">Eb</args>
  </opcode>
  <opcode mnemonic="sets">
    <return>Branch.None</return>
    <snippet>        $op1.set$cast(cpu.sf() ? 1 : 0));</snippet>
    <args size="8">Eb</args>
  </opcode>
  <opcode mnemonic="setns">
    <return>Branch.None</return>
    <snippet>        $op1.set$cast(!cpu.sf() ? 1 : 0));</snippet>
    <args size="8">Eb</args>
  </opcode>

  <opcode mnemonic="sar">
    <return>Branch.None</return>
    <snippet>        if($op2.get != 0)
        {
            boolean inOF = cpu.of();
            cpu.flagOp1 = $op1.get;
            cpu.flagOp2 = $op2.get;
            cpu.flagResult = $cast(cpu.flagOp1 &gt;&gt; cpu.flagOp2);
            $op1.set$castcpu.flagResult);
            cpu.flagIns = UCodes.SAR$size;
            cpu.flagStatus = OSZAPC;
            if (cpu.flagOp2 == 1)
                cpu.of(false);
            else
                cpu.of(inOF);
        }</snippet>
    <args size="8">Eb;I1</args>
    <args size="8">Eb;Ib</args>
    <args size="8">Eb;CL</args>
    <args size="16">Ew;I1</args>
    <args size="32">Ed;I1</args>
    <args size="16">Ew;Ib</args>
    <args size="32">Ed;Ib</args>
    <args size="16">Ew;CL</args>
    <args size="32">Ed;CL</args>
  </opcode>

  <opcode mnemonic="sgdt_o16">
      <return>Branch.None</return>
      <snippet>        int addr = $op1.get + op1.getBase(cpu);
        cpu.linearMemory.setWord(addr, (short)cpu.gdtr.getLimit());
        cpu.linearMemory.setDoubleWord(addr+2, cpu.gdtr.getBase() &amp; 0x00ffffff);</snippet>
    <args size="0">M</args>
  </opcode>

  <opcode mnemonic="sgdt_o32">
      <return>Branch.None</return>
      <snippet>        int addr = $op1.get + op1.getBase(cpu);
        cpu.linearMemory.setWord(addr, (short)cpu.gdtr.getLimit());
        cpu.linearMemory.setDoubleWord(addr+2, cpu.gdtr.getBase());</snippet>
    <args size="0">M</args>
  </opcode>

  <opcode mnemonic="sidt_o16">
      <return>Branch.None</return>
      <snippet>        int addr = $op1.get + op1.getBase(cpu);
        cpu.linearMemory.setWord(addr, (short)cpu.idtr.getLimit());
        cpu.linearMemory.setDoubleWord(addr+2, cpu.idtr.getBase() &amp; 0x00ffffff);</snippet>
    <args size="0">M</args>
  </opcode>
  <opcode mnemonic="sidt_o32">
      <return>Branch.None</return>
      <snippet>        int addr = $op1.get + op1.getBase(cpu);
        cpu.linearMemory.setWord(addr, (short)cpu.idtr.getLimit());
        cpu.linearMemory.setDoubleWord(addr+2, cpu.idtr.getBase());</snippet>
    <args size="0">M</args>
  </opcode>

  <opcode mnemonic="shl">
    <return>Branch.None</return>
    <snippet>        int shift = $op2.get &amp; 0x1f;
        if(shift != 0)
        {
            if (shift != 1)
            {
                cpu.of(cpu.of());
                cpu.flagStatus = SZAPC;
            }
            else
                cpu.flagStatus = OSZAPC;
            cpu.flagOp1 = $op1.get;
            cpu.flagOp2 = shift;
            cpu.flagResult = $cast(cpu.flagOp1 &lt;&lt; cpu.flagOp2);
            $op1.set$castcpu.flagResult);
            cpu.flagIns = UCodes.SHL$size;
        }</snippet>
    <args size="8">Eb;I1</args>
    <args size="8">Eb;Ib</args>
    <args size="8">Eb;CL</args>
    <args size="16">Ew;Gb</args>
    <args size="16">Ew;Ib</args>
    <args size="32">Ed;Ib</args>
    <args size="16">Ew;I1</args>
    <args size="32">Ed;I1</args>
    <args size="16">Ew;CL</args>
    <args size="32">Ed;CL</args>
  </opcode>

  <opcode mnemonic="shr">
    <return>Branch.None</return>
    <snippet>        if((0x1f &amp; $op2.get) != 0)
        {
            cpu.flagOp1 = $mask$op1.get;
            cpu.flagOp2 = 0x1f &amp; $op2.get;
            cpu.flagResult = $cast(cpu.flagOp1 &gt;&gt;&gt; cpu.flagOp2);
            $op1.set$castcpu.flagResult);
            cpu.flagIns = UCodes.SHR$size;
            cpu.flagStatus = OSZAPC;
        }</snippet>
    <args size="8">Eb;I1</args>
    <args size="8">Eb;Ib</args>
    <args size="8">Eb;CL</args>
    <args size="16">Ew;Gb</args>
    <args size="16">Ew;Ib</args>
    <args size="32">Ed;Ib</args>
    <args size="16">Ew;I1</args>
    <args size="32">Ed;I1</args>
    <args size="16">Ew;CL</args>
    <args size="32">Ed;CL</args>
  </opcode>

  <opcode mnemonic="shld">
    <return>Branch.None</return>
    <snippet>        if($op3.get != 0)
        {
            int shift = $op3.get &amp; 0x1f;
            cpu.flagOp1 = $op1.get;
            cpu.flagOp2 = shift;
            long rot = ((long)($mask$op1.get) &lt;&lt; (2*$size)) | ((0xffffffffL &amp; $mask$op2.get) &lt;&lt; $size) | ($mask$op1.get);
            cpu.flagResult = $cast((int)((rot &lt;&lt; shift) | (rot >>> (2*$size-shift))));
            $op1.set$castcpu.flagResult);
            cpu.flagIns = UCodes.SHLD$size;
            cpu.flagStatus = OSZAPC;
        }</snippet>
    <args size="16">Ew;Gw;Ib</args>
    <args size="16">Ew;Gw;CL</args>
  </opcode>
  <opcode mnemonic="shld">
    <return>Branch.None</return>
    <snippet>        if($op3.get != 0)
        {
            int shift = $op3.get &amp; 0x1f;
            cpu.flagOp1 = $op1.get;
            cpu.flagOp2 = shift;
            long rot = ((0xffffffffL &amp;$op2.get) &lt;&lt; $size) | (0xffffffffL &amp;$op1.get);
            cpu.flagResult = $cast((int)((rot &lt;&lt; shift) | (rot >>> (2*$size-shift))));
            $op1.set$castcpu.flagResult);
            cpu.flagIns = UCodes.SHLD$size;
            cpu.flagStatus = OSZAPC;
        }</snippet>
    <args size="32">Ed;Gd;Ib</args>
    <args size="32">Ed;Gd;CL</args>
  </opcode>

  <opcode mnemonic="shrd">
    <return>Branch.None</return>
    <snippet>        if($op3.get != 0)
        {
            int shift = $op3.get &amp; 0x1f;
            cpu.flagOp1 = $op1.get;
            cpu.flagOp2 = shift;
            long rot = ((long)$op1.get &lt;&lt; (2*$size)) | (($mask$op2.get) &lt;&lt; $size) | ($mask$op1.get);
            cpu.flagResult = $cast((int)(rot >> shift));
            $op1.set$castcpu.flagResult);
            cpu.flagIns = UCodes.SHRD$size;
            cpu.flagStatus = OSZAPC;
        }</snippet>
    <args size="16">Ew;Gw;Ib</args>
    <args size="16">Ew;Gw;CL</args>
  </opcode>
  <opcode mnemonic="shrd">
    <return>Branch.None</return>
    <snippet>        if($op3.get != 0)
        {
            int shift = $op3.get &amp; 0x1f;
            cpu.flagOp1 = $op1.get;
            cpu.flagOp2 = shift;
            long rot = ((0xffffffffL &amp;$op2.get) &lt;&lt; $size) | (0xffffffffL &amp; $op1.get);
            cpu.flagResult = $cast((int)(rot >> shift));
            $op1.set$castcpu.flagResult);
            cpu.flagIns = UCodes.SHRD$size;
            cpu.flagStatus = OSZAPC;
        }</snippet>
    <args size="32">Ed;Gd;Ib</args>
    <args size="32">Ed;Gd;CL</args>
  </opcode>

  <opcode mnemonic="smsw">
    <return>Branch.None</return>
    <snippet>        $op1.set$cast(0xFFFF &amp; cpu.getCR0()));</snippet>
    <args size="16">Ew</args>
    <args size="32">Ed</args>
  </opcode>

  <opcode mnemonic="sti">
    <return>Branch.None</return>
    <snippet>        if (cpu.getIOPrivilegeLevel() >= cpu.getCPL()) {
                        cpu.eflagsInterruptEnable = true;
                        cpu.eflagsInterruptEnableSoon = true;
                    } else {
                        if ((cpu.getIOPrivilegeLevel() &lt; cpu.getCPL()) &amp;&amp; (cpu.getCPL() == 3) &amp;&amp; ((cpu.getEFlags() &amp; (1 &lt;&lt; 20)) == 0)) {
                            cpu.eflagsInterruptEnableSoon = true;
                        } else
                            throw new ProcessorException(ProcessorException.Type.GENERAL_PROTECTION, 0, true);
                    }</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="stc">
    <return>Branch.None</return>
    <snippet>        cpu.cf(true);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="std">
    <return>Branch.None</return>
    <snippet>        cpu.df = true;</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="sbb">
    <return>Branch.None</return>
    <snippet>        int add = (cpu.cf()? 1: 0);
        cpu.flagOp1 = $op1.get;
        cpu.flagOp2 = $op2.get;
        cpu.flagResult = $cast(cpu.flagOp1 - (cpu.flagOp2 + add));
        $op1.set$castcpu.flagResult);
        cpu.flagIns = UCodes.SBB$size;
        cpu.flagStatus = OSZAPC;</snippet>
    <args size="8">AL;Ib</args>
    <args size="8">Eb;Ib</args>
    <args size="8">Eb;Gb</args>
    <args size="8">Gb;Eb</args>
    <args size="16">Ew;Ib</args>
    <args size="32">Ed;Ib</args>
    <args size="16">Ew;Iw</args>
    <args size="16">Ew;Gw</args>
    <args size="32">Ed;Gd</args>
    <args size="16">Gw;Ew</args>
    <args size="32">Gd;Ed</args>
  </opcode>

  <opcode mnemonic="sbb_o16">
    <return>Branch.None</return>
    <snippet>        int add = (cpu.cf()? 1: 0);
        cpu.flagOp1 = $op1.get;
        cpu.flagOp2 = $op2.get;
        cpu.flagResult = $cast(cpu.flagOp1 - (cpu.flagOp2 + add));
        $op1.set$castcpu.flagResult);
        cpu.flagIns = UCodes.SBB$size;
        cpu.flagStatus = OSZAPC;</snippet>
    <args size="16">rAX;Iw</args>
  </opcode>

  <opcode mnemonic="sbb_o32">
    <return>Branch.None</return>
    <snippet>        int add = (cpu.cf()? 1: 0);
        cpu.flagOp1 = $op1.get;
        cpu.flagOp2 = $op2.get;
        cpu.flagResult = $cast(cpu.flagOp1 - (cpu.flagOp2 + add));
        $op1.set$castcpu.flagResult);
        cpu.flagIns = UCodes.SBB$size;
        cpu.flagStatus = OSZAPC;</snippet>
    <args size="32">rAX;Id</args>
  </opcode>

  <opcode mnemonic="str">
    <return>Branch.None</return>
    <snippet>        $op1.set$castcpu.tss.getSelector());</snippet>
    <args size="16">Ew</args>
  </opcode>

  <opcode mnemonic="sub">
    <return>Branch.None</return>
    <snippet>        cpu.flagOp1 = $op1.get;
        cpu.flagOp2 = $op2.get;
        cpu.flagResult = $cast(cpu.flagOp1 - cpu.flagOp2);
        $op1.set$castcpu.flagResult);
        cpu.flagIns = UCodes.SUB$size;
        cpu.flagStatus = OSZAPC;</snippet>
    <args size="8">AL;Ib</args>
    <args size="8">Eb;Ib</args>
    <args size="8">Eb;Gb</args>
    <args size="8">Gb;Eb</args>
    <args size="16">Ew;Ib</args>
    <args size="32">Ed;Ib</args>
    <args size="32">Ed;Id</args>
    <args size="16">Ew;Iw</args>
    <args size="16">Ew;Gw</args>
    <args size="32">Ed;Gd</args>
    <args size="16">Gw;Ew</args>
    <args size="32">Gd;Ed</args>
  </opcode>

  <opcode mnemonic="sub_o16">
    <return>Branch.None</return>
    <snippet>        cpu.flagOp1 = $op1.get;
        cpu.flagOp2 = $op2.get;
        cpu.flagResult = $cast(cpu.flagOp1 - cpu.flagOp2);
        $op1.set$castcpu.flagResult);
        cpu.flagIns = UCodes.SUB$size;
        cpu.flagStatus = OSZAPC;</snippet>
    <args size="16">rAX;Iw</args>
  </opcode>

  <opcode mnemonic="sub_o32">
    <return>Branch.None</return>
    <snippet>        cpu.flagOp1 = $op1.get;
        cpu.flagOp2 = $op2.get;
        cpu.flagResult = $cast(cpu.flagOp1 - cpu.flagOp2);
        $op1.set$castcpu.flagResult);
        cpu.flagIns = UCodes.SUB$size;
        cpu.flagStatus = OSZAPC;</snippet>
    <args size="32">rAX;Id</args>
  </opcode>

  <opcode mnemonic="test">
    <return>Branch.None</return>
    <snippet>        cpu.of = cpu.af = cpu.cf = false;
        cpu.flagResult = $cast($op1.get &amp; $op2.get);
        cpu.flagStatus = SZP;</snippet>
    <args size="8">AL;Ib</args>
    <args size="8">Eb;Gb</args>
    <args size="8">Eb;Ib</args>
    <args size="16">Ew;Gw</args>
    <args size="32">Ed;Gd</args>
    <args size="16">Ew;Iw</args>
    <args size="32">Ed;Id</args>
  </opcode>

  <opcode mnemonic="test_o16">
    <return>Branch.None</return>
    <snippet>        cpu.of = cpu.af = cpu.cf = false;
        cpu.flagResult = $cast($op1.get &amp; $op2.get);
        cpu.flagStatus = SZP;</snippet>
        <args size="16">rAX;Iw</args>
  </opcode>

  <opcode mnemonic="test_o32">
    <return>Branch.None</return>
    <snippet>        cpu.of = cpu.af = cpu.cf = false;
        cpu.flagResult = $cast($op1.get &amp; $op2.get);
        cpu.flagStatus = SZP;</snippet>
        <args size="32">rAX;Id</args>
  </opcode>

  <opcode mnemonic="ud2">
    <return>Branch.Exception</return>
    <snippet>        if (true) throw ProcessorException.UNDEFINED;</snippet>
        <args size="0"></args>
  </opcode>

  <opcode mnemonic="verr">
    <return>Branch.None</return>
    <snippet>            try {
			Segment test = cpu.getSegment($op1.get &amp; 0xffff);
			int type = test.getType();
			if (((type &amp; ProtectedModeSegment.DESCRIPTOR_TYPE_CODE_DATA) == 0) || (((type &amp; ProtectedModeSegment.TYPE_CODE_CONFORMING) == 0) &amp;&amp; ((cpu.getCPL() > test.getDPL()) || (test.getRPL() > test.getDPL()))))
			    cpu.zf(false);
			else
			    cpu.zf(((type &amp; ProtectedModeSegment.TYPE_CODE) == 0) &amp;&amp; ((type &amp; ProtectedModeSegment.TYPE_CODE_READABLE) != 0));
		    } catch (ProcessorException e) {
			cpu.zf(false);
		    }</snippet>
    <args size="16">Ew</args>
  </opcode>

  <opcode mnemonic="verw">
    <return>Branch.None</return>
    <snippet>            try {
			Segment test = cpu.getSegment($op1.get &amp; 0xffff);
			int type = test.getType();
			if (((type &amp; ProtectedModeSegment.DESCRIPTOR_TYPE_CODE_DATA) == 0) || (((type &amp; ProtectedModeSegment.TYPE_CODE_CONFORMING) == 0) &amp;&amp; ((cpu.getCPL() > test.getDPL()) || (test.getRPL() > test.getDPL()))))
			    cpu.zf(false);
			else
			    cpu.zf(((type &amp; ProtectedModeSegment.TYPE_CODE) == 0) &amp;&amp; ((type &amp; ProtectedModeSegment.TYPE_DATA_WRITABLE) != 0));
		    } catch (ProcessorException e) {
			cpu.zf(false);
		    }</snippet>
    <args size="16">Ew</args>
  </opcode>

  <opcode mnemonic="wbinvd">
    <return>Branch.None</return>
    <snippet>            if (cpu.getCPL() != 0) throw new ProcessorException(ProcessorException.Type.GENERAL_PROTECTION, 0, true);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rdmsr">
    <return>Branch.None</return>
    <snippet>            if (cpu.getCPL() != 0) throw new ProcessorException(ProcessorException.Type.GENERAL_PROTECTION, 0, true);//ProcessorException.GENERAL_PROTECTION_0;
	long msr = cpu.getMSR(cpu.r_ecx.get32());
        cpu.r_eax.set32((int) msr);
        cpu.r_edx.set32((int)(msr >> 32));</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="wrmsr">
    <return>Branch.None</return>
    <snippet>            if (cpu.getCPL() != 0) throw new ProcessorException(ProcessorException.Type.GENERAL_PROTECTION, 0, true);//ProcessorException.GENERAL_PROTECTION_0;
		    cpu.setMSR(cpu.r_ecx.get32(), (cpu.r_eax.get32() &amp; 0xffffffffl) | ((cpu.r_edx.get32() &amp; 0xffffffffl) &lt;&lt; 32)); </snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="xadd">
    <return>Branch.None</return>
    <snippet>            int tmp1 = $op1.get;
        int tmp2 = $op2.get;
        cpu.flagOp1 = tmp1;
        cpu.flagOp2 = tmp2;
        cpu.flagResult = $cast(cpu.flagOp1 + cpu.flagOp2);
        $op1.set$castcpu.flagResult);
        cpu.flagIns = UCodes.ADD$size;
        cpu.flagStatus = OSZAPC;
        $op2.settmp1);
        $op1.settmp1+tmp2);</snippet>
    <args size="32">Ed;Gd</args>
  </opcode>

  <opcode mnemonic="xchg">
    <return>Branch.None</return>
    <snippet>            int tmp = $op2.get;
        $op2.set$op1.get);
        $op1.set$casttmp);</snippet>
    <args size="8">Eb;Gb</args>
    <args size="16">Ew;Gw</args>
    <args size="32">Ed;Gd</args>
  </opcode>

  <opcode mnemonic="xchg_o16">
    <return>Branch.None</return>
    <snippet>            int tmp = $op2.get;
        $op2.set$op1.get);
        $op1.set$casttmp);</snippet>
    <args size="16">rCXr9;rAX</args>
    <args size="16">rDXr10;rAX</args>
    <args size="16">rBXr11;rAX</args>
    <args size="16">rSPr12;rAX</args>
    <args size="16">rBPr13;rAX</args>
    <args size="16">rSIr14;rAX</args>
    <args size="16">rDIr15;rAX</args>
  </opcode>

  <opcode mnemonic="xchg_o32">
    <return>Branch.None</return>
    <snippet>            int tmp = $op2.get;
        $op2.set$op1.get);
        $op1.set$casttmp);</snippet>
    <args size="32">rCXr9;rAX</args>
    <args size="32">rDXr10;rAX</args>
    <args size="32">rBXr11;rAX</args>
    <args size="32">rBPr13;rAX</args>
    <args size="32">rSPr12;rAX</args>
    <args size="32">rSIr14;rAX</args>
    <args size="32">rDIr15;rAX</args>
  </opcode>

  <opcode mnemonic="xlatb_a16" segment="true">
    <return>Branch.None</return>
    <snippet>        cpu.r_al.set8(seg.getByte((0xffff&amp;cpu.r_bx.get16()) + (0xff &amp; cpu.r_al.get8())));</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="xlatb_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        cpu.r_al.set8(seg.getByte(cpu.r_ebx.get32() + (0xff &amp; cpu.r_al.get8())));</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="xor">
    <return>Branch.None</return>
    <snippet>        cpu.of = cpu.af = cpu.cf = false;
        cpu.flagResult = $cast($op1.get ^ $op2.get);
        $op1.set$castcpu.flagResult);
        cpu.flagStatus = SZP;</snippet>
    <args size="8">AL;Ib</args>
    <args size="8">Eb;Ib</args>
    <args size="8">Eb;Gb</args>
    <args size="8">Gb;Eb</args>
    <args size="16">Ew;Ib</args>
    <args size="32">Ed;Ib</args>
    <args size="32">Ed;Id</args>
    <args size="16">Ew;Gw</args>
    <args size="32">Ed;Gd</args>
    <args size="16">Gw;Ew</args>
    <args size="32">Gd;Ed</args>
    <args size="16">rAX;Iw</args>
    <args size="32">rAX;Id</args>
  </opcode>
</opcodesnippets>